<!doctype html>
<html>

<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>

<body>

    <script>

    //---------Interface V3----------//
    /*

    This version currently supports:

        -dragging boxes
        -allowing the user to place them in one of the empty slots
        -keeping track of placed commands
        -successfully changing parameters of different
            CommandBlock types using the respective buttons
        -passing those params to a function assigned to the CommandBlock at creation.

        The command queue is a Doubly Linked List.

        Current Issues:
        TODO: DoublyLinkedList currently will insertAfter properly, but does NOT
              properly delete (removeNode) the one that is sent to it by that function.
        TODO: The green box SVG that is supposed to execute the commands in order
              does not call any or all of the functions attached to the nodes'
              CommandBlocks.
        TODO: Not a big issue, but fix the control flow of the updateBox() function
              to properly use and set the CommandBlock.placed attribute.

    */

    //---Name Classes---//

    class EmptyBlock {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.type = 'empty';
            this.visRef = this.createBlank();
        }

        createBlank() {
            var boxW = (window.innerWidth * 1.2)/10;
            var boxH = (window.innerHeight * 1.2)/10;

            var blank = d3.select('.binder').append('rect')
               .attr('width', boxW)
               .attr('height', boxH)
               .attr('x', this.x)
               .attr('y', this.y)
               .style('stroke', '#999')
               .style('fill', '#ddd')
               .style('stroke-width', 1)
               .style('stroke-dasharray', '10 7')
            return blank;
        }

        removeEmptyBlock() {
            this.visRef.remove();
        }

        callCommand(){
            return;
        }
    }

    class CommandBlock {
        constructor (x, y, type, commandFn, params){
            this.x = x;
            this.y = y;
            this.height = (window.innerHeight*1.2)/10+5;
            this.width = (window.innerWidth*1.2)/10+5;
            this.commandFn = commandFn;
            this.params = [];
            this.type = type;
            this.placed = false;
            this.visRef = this.draw(this);

            console.log(this.visRef);
        }

        draw(commandBlock) {
            //commandBlock takes itself in draw because when the SVG is selected, it becomes 'this'
            //so we have to specify that we want the commandBlock's attributes to change, unfortunately.
            var box = d3.select('.binder').append('svg')
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height)
                .call(d3.drag().on('start', activateBox)
                    .on('drag', updateBox(commandBlock))
                    .on('end', deactivateBox));

            box.append('rect') //the block itself
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', this.width)
                .attr('height', this.height)
                .attr('stroke', 'black')
                .attr('stroke-width', 3)
                .attr('fill', '#ddd')
                .attr('class', 'block');

            var t = commandBlock.type;

            switch(t) {
                case 'goOutAtAngle':
                    commandBlock.creategoOutAtAngle(commandBlock, box);
                    break;
                case 'goToCenter':
                    commandBlock.createGoToCenter(commandBlock, box);
                    break;
                case 'waitFor':
                    commandBlock.createWaitFor(commandBlock, box);
                    break;
                case 'wait':
                    commandBlock.createWait(commandBlock, box);
                    break;
                case 'waitAverage':
                    commandBlock.createWaitAverage(commandBlock, box);
                    break;
                case 'followWall':
                    commandBlock.createFollowWall(commandBlock, box);
                    break;
                case 'followWallFor':
                    commandBlock.createFollowWallFor(commandBlock, box);
                    break;
            }

            /*

            if (t == 'goOutAtAngle') {
                commandBlock.creategoOutAtAngle(commandBlock, box);
            }
            else if (t == 'waitFor') {
                commandBlock.createWaitFor(commandBlock, box);
            }

            */

            return box;


        }

        callCommand(commandBlock) {
            return function () { //closure scope, only calls function when button is clicked
                commandBlock.commandFn(commandBlock.params);
            }
        }

        //TODO create all blocks with specific array parameters.

        //all functions below return box as SVG

        //goOutAtAngle.params = [int angle]
        creategoOutAtAngle(commandBlock, box) {

            var fo = box.append('foreignObject')
                .attr('x', this.width/3)
                .attr('y', 10)
                .attr('width', 50);

            var textBox = fo.append('xhtml:div').append('div').append('input')
                .attr('name', 'Angle')
                .attr('type', 'number')
                .attr('min', 0)
                .attr('max', 360)
                .attr('value', 0)
                .attr('class', 'textbox')
                .on('mouseDown', deactivateBox); // so the box doesnt move when the textbox arrows are held...

            var label = box.append('text')
                .text('Go at angle')
                .style('font-size', '20px')
                .style('fill', 'black')
                .attr('transform', 'translate(20, 100) rotate(0)')
                .attr('text-anchor', 'left')
                .attr('class', 'infotext')

            box.append('rect') // the button
                .attr('x', this.width/3)
                .attr('y', this.height/3)
                .attr('width', '30%')
                .attr('height', '20%')
                .attr('stroke', 'black')
                .attr('fill', '#68ff63')
                .on('click', function () {
                    if (commandBlock.params.length == 0){
                        commandBlock.params.push(+d3.select(this.parentNode).select('.textbox').property('value')); //selects parent svg of the button, then goes back into the children to find the textbox input
                    }
                    else{
                        commandBlock.params[0] = +d3.select(this.parentNode).select('.textbox').property('value');
                    }
                    console.log(commandBlock.params);
                    d3.select(this.parentNode).select('.infotext').remove();
                    label = d3.select(this.parentNode).append('text')
                        .text('Go at angle: ' + commandBlock.params)
                        .style('font-size', '20px')
                        .style('fill', 'black')
                        .attr("transform", "translate(20, 100) rotate(0)")
                        .attr('text-anchor', 'left')
                        .attr('class', 'infotext');
            });

            return box;

        }

        //goToCenter.params = [], takes 1 time to get there.
        createGoToCenter(commandBlock, box) {
            var label = box.append('text')
                .text('Go to center')
                .style('font-size', '20px')
                .style('fill', 'black')
                .attr('transform', 'translate(20, 100) rotate(0)')
                .attr('text-anchor', 'left')
                .attr('class', 'infotext')
        }


        //waitFor.params = [int time]
        createWaitFor(commandBlock, box) {

            var fo = box.append('foreignObject')
                .attr('x', this.width/3)
                .attr('y', 10)
                .attr('width', 50);

            var textBox = fo.append('xhtml:div').append('div').append('input')
                .attr('name', 'Wait for: ')
                .attr('type', 'number')
                .attr('min', 0)
                .attr('max', 9999)
                .attr('value', 0)
                .attr('class', 'textbox')
                .on('mouseDown', deactivateBox); // so the box doesnt move when the textbox arrows are held...

            var label = d3.select(this.parentNode).append('text')
                .text('Wait for: ')
                .style('font-size', '20px')
                .style('fill', 'black')
                .attr('transform', 'translate(20, 100) rotate(0)')
                .attr('text-anchor', 'left')
                .attr('class', 'infotext');

            box.append('rect') // the button
                .attr('x', this.width/3)
                .attr('y', this.height/3)
                .attr('width', '30%')
                .attr('height', '20%')
                .attr('stroke', 'black')
                .attr('fill', '#68ff63')
                .on('click', function () {
                    if (commandBlock.params.length == 0){
                        commandBlock.params.push(+d3.select(this.parentNode).select('.textbox').property('value'));
                    }
                    else{
                        commandBlock.params[0] = +d3.select(this.parentNode).select('.textbox').property('value');
                    }
                    console.log(commandBlock.params);
                    d3.select(this.parentNode).select('.infotext').remove();
                    label = d3.select(this.parentNode).append('text')
                        .text('Wait for: ' + commandBlock.params)
                        .style('font-size', '20px')
                        .style('fill', 'black')
                        .attr("transform", "translate(20, 100) rotate(0)")
                        .attr('text-anchor', 'left')
                        .attr('class', 'infotext');
            });

        }

        //wait.params = [], wait indefinitely.
        createWait(commandBlock, box){
            var label = box.append('text')
                .text('Wait')
                .style('font-size', '20px')
                .style('fill', 'black')
                .attr('transform', 'translate(20, 100) rotate(0)')
                .attr('text-anchor', 'left')
                .attr('class', 'infotext')
        }

        //waitAverage.params = []
        createWaitAverage(commandBlock, box) {

        }

        //followWallFor.params = [string direction, int angle(time)]
        createFollowWallFor(commandBlock, box) {

        }

        //followWall.params = [string direction]
        createFollowWall(commandBlock, box) {
            var label = box.append('text')
                .text('Follow wall')
                .style('font-size', '20px')
                .style('fill', 'black')
                .attr('transform', 'translate(20, 100) rotate(0)')
                .attr('text-anchor', 'left')
                .attr('class', 'infotext')
        }

        removeCommandBlock(commandBlock) {
            this.visRef.remove();
        }




    }

    function Node(data) {
        this.data = data;
        this.prevNode = null;
        this.nextNode = null;
    }

    class DoublyLinkedList {
        constructor() {
            this.head = null;
            this.tail = null;
            this.totalLength = 0;
        }

        add(data) {
            const node = new Node(data);
            if (!this.head) {
                this.head = node;
                this.tail = node;
            }
            else {
                node.prevNode = this.tail;
                this.tail.nextNode = node;
                this.tail = node;
            }
            this.totalLength ++;
        }

        removeNode(data) {
            var current = this.head;
            while (current) {
                if (current.data == data.data) {

                    if (current === this.head && current === this.tail) {
                        this.head = null;
                        this.tail = null
                    }
                    else if (current === this.head) {
                        this.head = this.head.nextNode;
                        this.head.prevNode = null;
                    }
                    else if (current === this.tail) {
                        this.tail = this.tail.prevNode;
                        this.tail.nextNode = null;
                    }
                    else {
                        console.log('i am in here');
                        current.prevNode.nextNode = current.nextNode;
                        current.nextNode.prevNode = current.prevNode;
                    }
                    this.totalLength--;
                }
                current = this.nextNode;
            }
        }

        insertAfter(data, node) {
            var current = this.head;

            while (current) {
                if (current === node) {
                    const node = new Node(data);
                    if (current === this.tail) {
                        this.add(node);
                        return;
                    }
                    else {
                        current.nextNode.prevNode = node;
                        node.prevNode = current;
                        node.nextNode = current.nextNode;
                        current.nextNode = node;
                        this.totalLength++;
                        return;
                    }
                }
                current = current.nextNode
            }
        }

        traverse(fn) {
            var current = this.head;
            while (current) {
                if (fn) {
                    fn(current);
                }
                current = current.prevNode;
            }
        }

        length() {
            return this.totalLength;
        }

        print() {
            var string = '';
            var current = this.head;
            while(current) {
                string += `${current.data} `;
                current = current.nextNode;
            }
            console.log(string.trim());
        }
    }


    //---Instantiate Variables---//
    var winWidth = window.innerWidth;
    var winHeight = window.innerHeight;
    var emptyQueue = [];
    var commandQueue = [];
    var looseCommands = [];
    var dll = new DoublyLinkedList();
    var flag = false;
    console.log(winWidth);
    console.log(winHeight);

    var win = d3.select('body').append('svg')
              .attr('width', winWidth)
              .attr('height', winHeight)
              .attr('class', 'binder');

    var commandsList = [['goOutAtAngle', testCommands], ['goToCenter', testCommands],
                        ['waitFor', testCommands], ['wait', testCommands],
                        ['waitAverage', testCommands], ['followWallFor', testCommands],
                        ['followWall', testCommands]]


    //---Name Functions---//

        //Takes x1, y1, x2, y2, as ints.
    function distance(x1, y1, x2, y2) {
        return Math.sqrt(((x2 - x1)*(x2-x1)) + ((y2-y1)*(y2-y1)));
    }

        //Takes x as int, y as int.
    function createBlank(x, y) {
        var boxW = (window.innerWidth * 1.2)/10;
        var boxH = (window.innerHeight * 1.2)/10;

        var blank = d3.select('.binder').append('rect')
           .attr('width', boxW)
           .attr('height', boxH)
           .attr('x', x)
           .attr('y', y)
           .style('stroke', '#999')
           .style('fill', '#ddd')
           .style('stroke-width', 1)
           .style('stroke-dasharray', '10 7')
        return blank;
    }

    function activateBox() {
        d3.select(this).attr('stroke', 'gray').attr('fill', '#ccc').attr('class', 'commandBox');
        d3.select(this).classed('active', true);
    }

    function updateBox(commandBlock) {
        return function () {

            if (commandBlock.placed) {
                return;
            }
            else if (commandBlock.placed){
            }
            var mousePosX = d3.event.x;
            var mousePosY = d3.event.y;
            var newCommand = false;

            d3.select(this).attr('x', mousePosX).attr('y', mousePosY);
            commandBlock.x = mousePosX;
            commandBlock.y = mousePosY;
            current = dll.head;

            for (r=0;r<dll.length();r++) {
                var x1 = current.data.x; //dab
                var y1 = current.data.y;

                if (commandBlock.placed) {
                    d3.select(this).classed('dragging', false);
                }

                if (!commandBlock.placed && distance(x1, y1, mousePosX, mousePosY) <= 40 && current.data.type == 'empty' ) {
                    d3.select(this).attr('x', x1-1).attr('y', y1-1);
                    window.dll.insertAfter(commandBlock, current);
                    console.log(current.data);
                    window.dll.removeNode(current);
                    dll.removeNode(current);
                    commandBlock.placed = !commandBlock.placed;
                    d3.select(this).classed('dragging', false);
                    break;

                }
                else if (current.data.type != 'empty' && distance(x1, y1, mousePosX, mousePosY) > 40 ) {
                    //var empty = new EmptyBlock(x1, y1);
                    //dll.replaceDataAt(current, empty);
                }

                current = current.nextNode;
            }
        }
        //need to change the internal object's x and y positions as well as the svg.
        //consider adding method to the class and calling commandBlock.updateBox instead.

    }

    function checkEmpty(node) {
        if (node.type == 'empty') {

        }
    }

    function deactivateBox() {
        d3.select(this).attr('stroke', 'black').attr('fill', '#ddd');
        d3.select(this).classed('dragging', false);
    }

    // Takes type as a string, commandFn as a function, posX, posY as int.
    function drawCommandList(type, commandFn, posX, posY) {
        var box = d3.select('.binder').append('svg')
            .attr('x', posX)
            .attr('y', posY)
            .attr('width', '15%')
            .attr('height', '10%');
        box.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', '100%')
            .attr('height', '100%')
            .style('stroke', 'black')
            .attr('stroke-width', 3)
            .attr('fill', '#ddd')
            //creates a new CommandBlock object on click and sends it to the loose command Queue.
            .on('click', function() {looseCommands.push(new CommandBlock(d3.event.x, d3.event.y, type, commandFn, []));});
        box.append('text')
            .text(type)
            .style('font-size', '24px')
            .style('fill', 'black')
            .attr("transform", "translate(10, 50) rotate(0)")
            .attr('text-anchor', 'left')
            .attr('class', 'infotext');
    }

    function Initialize() {
        var winW = window.innerWidth;
        var winH = window.innerHeight;

        for (i=0;i<3;i++) {
            dll.add(new EmptyBlock(winW * 0.05, i*(winH*0.15)+50));
        }
        console.log(dll);

    }


    //---Set up boundaries---//
    win.append('line')
        .attr('x1', winWidth * 0.6)
        .attr('y1', 0)
        .attr('x2', winWidth * 0.6)
        .attr('y2', winHeight)
        .style('stroke', '#000')
        .attr('stroke-width', 3);

    // Draw up a list of command boxes to click on.
    for (i = 0; i < commandsList.length; i++) {
        var posX = winWidth * 0.7;
        var posY = winHeight/15 + (i * (winHeight/9));
        type = commandsList[i][0];
        commandFn = commandsList[i][1];
        drawCommandList(type, commandFn, posX, posY);
    }

    Initialize();


    //var testCommand = new CommandBlock(400, 400, 'goOutAtAngle', testCommands, []);
    //var test2 = new CommandBlock(100, 300, 'waitFor', testCommands, []);


    function testCommands(parameter) {
        console.log('the command block passed me a parameter');
        console.log(parameter);
    }

    var start = win.append('svg')
        .attr('x', winWidth * 0.7)
        .attr('y', winHeight/15 + (commandsList.length * (winHeight/9)))
        .attr('width', '10%')
        .attr('height', '10%')
    .append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('stroke', 'green')
        .attr('fill', '#a3ffa0')
        .on('click', function(){
            current = dll.head;
            while (current) {
                console.log(current);
                if (current != null && current.data.type != 'empty') {
                    current.data.callCommand(current.data);
                }
                current = current.nextNode;
            }
        });

    var del = win.append('svg')
        .attr('x', winWidth * 0.82)
        .attr('y', winHeight/15 + (commandsList.length * (winHeight/9)))
        .attr('width', '10%')
        .attr('height', '10%')
    .append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('stroke', 'green')
        .attr('fill', '#ff6e51')
        .on('click', function() {
            //removes all 'loose commands' AKA commands which have not been implemented yet
            //from the screen.
            for (i=0;i<looseCommands.length;i++){
                var cB = looseCommands[i];
                cB.removeCommandBlock(cB);
                delete(looseCommands[i]);
                console.log(looseCommands);
            }
            looseCommands = [];
            console.log(looseCommands);
        });

    </script>

    <g>
        <button name="test button" type="submit" value="submit-true">If you see this at the top left the website crashed.</button>
    </g>
</body>

</html>
