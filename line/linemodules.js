'use strict';
var worldo;

class utils {

    constructor() {}


    /**
    *Calculate point on path at angle relative to center and shape.
    *
    * @param {Array} path path of a shape, usually generated by utils.genPoly.
    * @param {Object} center {x,y} coordinates of center of shape.
    * @param {float} angle Angle of point 0-360.
    */
    static wallAtAngle(path, center, angle) {
        var unit2Px = 25;
        for( var i = 0; i < path.length - 1; i++ ) {
          var hold = utils.WhereLineSegsCross(
            center,
            {
              x:center.x + 8 * unit2Px * Math.cos( angle * Math.PI / 180 ),
              y:center.y - 8 * unit2Px * Math.sin( angle * Math.PI / 180 )
            },
            path[ i ],
            path[ i + 1 ]
          );
          if( hold ) {
            return hold;
          }
        }
        return null;
    }

    /**
    * Generates a polygon with n sides, radius r (center to vertex), and angle of rotation a.
    *
    * @param {Object} c {x,y} coordinates center of shape.
    * @param {float} r distance from center point to each. radius.
    * @param {float} a angle of rotation of all sides.
    * @param {integer} n Number of sides. 3 for triangle, 360 for circle, etc.
    */
    static genPoly(c, r, a, n) {
        var poly = [];
        for (var i = 0; i < n; i++) {
            var sumAng = (a * Math.PI / 180) + (i * 2 * Math.PI / n);
            poly.push({
                x: c.x + r * Math.cos(sumAng),
                y: c.y - r * Math.sin(sumAng)
            });
        }
        poly.push(poly[0]);
        return (poly);
    }

    /**
    *Return distance between two points.
    * @param {Object} p1 {x,y} coordinates of point 1.
    * @param {Object} p2 {x,y} coordinates of point 2.
    */
    static distance( p1, p2 ) {
      return( Math.hypot( p2.y - p1.y, p2.x - p1.x ) );
    }

    /**
    *Returns {x,y} coordinates of midpoint between two points.
    *
    * @param {Object} p1 {x,y} coordinates of point 1.
    * @param {Object} p2 {x,y} coordinates of point 2.
    */
    static midpoint(pt1, pt2) {
        if (pt1.x == pt2.x && pt1.y == pt2.y) {
            console.log("%cERROR: Must be different points.", "color:#ff0000ff");
            return null;
        }
        return {x:(pt1.x + pt2.x)/2, y:(pt1.y + pt2.y)/2};
    }

    /**
    *Returns whether {x,y} pairs are equal.
    *
    * @param {Object} v1 {x,y} coordinates of point 1.
    * @param {Object} v2 {x,y} coordinates of point 2.
    */
    static cmpXYPairs( v1, v2 ) {
      if( ( v1.x == v2.x ) && ( v1.y == v2.y ) ) {
        return( true );
      }
      return( false );
    }

    /**
    * Returns a value within a certain range given a value higher or lower.
    */
    static AddAround( val, max, amt ) {
      if( max < 1 ) {
        console.log( "%cERROR: max must be positive", "color:#ff0000" );
        return( null );
      }
      if( !amt ) {
        console.log( "%cERROR: amt must be nonzero", "color:#ff0000" );
        return( null );
      }
      var hold = val + amt;
      while( 1 ) {
        if( hold < 0 ) {
          hold += max;
        } else if( hold >= max ) {
          hold -= max;
        } else {
          return( hold );
        }
      }
    }

    /**
    *Returns a {x,y} point where two line segments cross.
    *Points 1,2 are the first line segment,
    *points 3,4 are the second line segment.
    *
    * @param {Object} pt1 {x,y} coordinates of point 1.
    * @param {Object} pt2 {x,y} coordinates of point 2.
    * @param {Object} pt3 {x,y} coordinates of point 3.
    * @param {Object} pt4 {x,y} coordinates of point 4.
    */
    static WhereLineSegsCross( pt1, pt2, pt3, pt4 ) {
      if( pt1.x > pt2.x ) {
        var hold = pt1;
        pt1 = pt2;
        pt2 = hold;
      }
      var a1 = ( pt2.y - pt1.y ) / ( pt2.x - pt1.x );	//slope
      var b1 = 1;
      if( pt2.x - pt1.x == 0 ) {	//Line one is vertical, change values to proper equation
        a1 = 1;
        b1 = 0;
      }
      var c1 = b1 * pt1.y - a1 * pt1.x;	//y-intercept

      if( pt3.x > pt4.x ) {
        var hold = pt3;
        pt3 = pt4;
        pt4 = hold;
      }
      var a2 = ( pt4.y - pt3.y ) / ( pt4.x - pt3.x );
      var b2 = 1;
      if( pt4.x - pt3.x == 0 ) {	//Line two is vertical, change values to proper equation
        a2 = 1;
        b2 = 0;
      }
      var c2 = b2 * pt3.y - a2 * pt3.x;

      var s1 = ( b1 * pt3.y - a1 * pt3.x - c1 ) * ( b1 * pt4.y - a1 * pt4.x - c1 );
      var s2 = ( b2 * pt1.y - a2 * pt1.x - c2 ) * ( b2 * pt2.y - a2 * pt2.x - c2 );

      if( s1 <= 0 && s2 <= 0 ) {
        var d = a1 * b2 - a2 * b1;
        if( d == 0 ) {
          return( null );
        }
        var dx = c1 * b2 - c2 * b1;
        var dy = a1 * c2 - a2 * c1;
        //console.log( pt1, pt2, pt3, pt4 );
        //console.log( "1: ", "a1:" + a1, "b1:" + b1, "c1:" + c1, "a2:" + a2, "b2:" + b2, "c2:" + c2 );
        //console.log( "2: ", "dx:" + dx, "dy:" + dy, "d:" + d, "dxld:" + dx / d, "dyld:" + dy / d );
        return( { x:-dx / d, y:dy / d } );
      }
      return( null );
    }

}

/**
 *Data necessary to run a simulation of a given algorithm, create visual paths, etc.
 *Tourist == Agent == Robot.
 *
 * @param {integer} id Global identifier of this object.
 * @param {Array} instruBinder Array of valid trajectories for Tourists to follow. Length of this is touristNum.
 * @param {string} algorithmName Full clean name of the algorithm instruBinder is supposed to represent.
 * @param {float} angle Angle of the exit location on the shape. Exit location will be at the wall of the shape.
 * @param {boolean} wireless True if using Wireless communication model, false otherwise.
 * @param {Array} path An array of points with which to create the target shape.
 * @param {Object} start {x, y} coordinates of tourist start location.
 *
 */
class iclData {
    constructor(id, instruBinder, algorithmName, exit, wireless, start, lineLength) {
        /** Someone learned where the exit is. */
        this.exitAlert = false;
        /** How far into a frame the exit was found. */
        this.exitAllow = 0;
        /** Whether or not the simulation is using the wireless model. */
        this.wireless = wireless;
        /** Global identifier to this data structure. */
        this.id = id;
        /** Current time of the simulation (frames). */
        this.time = 0;
        /** Current velocity of the simulation. 1 - Forward. 0 - Stopped. -1 - Rewind. (0,1) - Slow */
        this.timeDirect = 0;
        /** Frames per second. Too high (> 100) == bad performance. */
        this.fps = 100;
        /** The maximum time before we stop the simulation for good. */
        this.timeMax = 3 * this.fps;
        /** Points of the equilateral shape to search. Ex. 3 = Triangle, 4 = square, 360 = circle */
        this.degrees = 2;
        // 60 pixel path length for now.
        this.pathLength = 60;
        this.maxPx = 80;
        this.minPx = 20;
        this.path = [{x:20, y:35}, {x:80, y:35}];
        /** 1 unit == 1 Radius. How many pixels per unit. */
        this.points = (lineLength < Math.abs(exit * 2)) ? Math.abs(exit * 2) : lineLength;
        this.unit2Px = this.pathLength / Math.abs(this.points);
        this.animSpeed = 2;
        this.step = this.unit2Px/(this.fps / this.animSpeed);
        /** Center of the current shape in {float}[x,y]. */
        this.center = {
            x:50,
            y:35
        };
        this.origin = {x:this.center.x, y:35}
        /** tourist start location */
        this.start = start;

        this.exit = exit;

        if (this.exit < 0){
            this.exitLoc = {x:this.center.x + (exit * this.unit2Px), y:this.center.y}
        }
        else {
            this.exitLoc = {x:this.center.x + (exit * this.unit2Px), y:this.center.y}
        }


        this.totalTime = (this.exit * 9 + 2) * this.step;

        /** Exit to use for the sim in {float}[x,y]. */
        this.fieldExit = {x:exit};
        /** How many tourists this data structure is in control of. */
        this.touristNum = 0;
        /** Array of valid trajectories for robots. Length is how many tourists are being used. */
        this.instruBinder = instruBinder;
        /** Full clean name of algorithm. */
        this.algorithmName = algorithmName;
        /** Array of {Tourist}s */
        this.tourists = [];

        this.maxSearched = [this.center.x];
        this.minSearched = [this.center.x];

        /** Interval for this iclData instance. Typically set to 1000/fps. Initialized to just a number.*/
        this.motor = this.id;

        this.pPath = this.genLine(20, 35, 80, 35);

        this.history = null;

        this.mods = [];

        this.timeDirect = 1;

        this.allKnowing = false;
    }

    genLine(x1, y1, x2, y2) {
        var pPath = [];
        for (var i = 0; i <=  this.points * this.fps; i++) {
            pPath.push({x:x1 + (this.step * i)})
        }
        //console.log(pPath);
        return pPath;
    }


    Init() {
        this.time = 0; //Reset time
        this.tourists = []; //Reset mobiles for run
        for (var i = 0; i < this.instruBinder.length; i++) { //Refill mobiles for run

            this.tourists.push(new Tourist(
                this, this.start.x, this.start.y, i, this.instruBinder[i], this.instruBinder[i][0][1]));
        }
        for (var j = 0; j < this.mods.length; j++) { //Reset modules
            if (this.mods[j].Init) {
                this.mods[j].Init();
            }
        }

    }

    createHistory() {
        this.Init();

        this.history = []; //Reset History
        for (var i = 0; i < this.instruBinder.length; i++) {
            this.history.push([]);
        }
        for (var k = 0; k < Math.abs(2 * this.exit) * Math.abs(2 * this.exit) * this.fps + (this.pPath.length * 2); k++) {
            if (this.allKnowing) {
                break;
            }
            var maxAdded = false;
            var minAdded = false;
            for (var i = 0; i < this.instruBinder.length; i++) {
                var who = this.tourists[i];
                this.history[i].push({
                    x: who.x,
                    y: who.y
                });
                if (who.x > this.maxSearched[this.time - 1]) {
                    if (!maxAdded) {
                        this.maxSearched.push(who.x);
                        maxAdded = true;

                    }
                    else {
                        this.maxSearched[this.maxSearched.length-1] = who.x;

                    }
                }


                if (who.x < this.minSearched[this.time - 1]) {
                    if (!minAdded) {
                        this.minSearched.push(who.x);
                        minAdded = true;
                    }
                    else {
                        this.minSearched[this.minSearched.length-1] = who.x;
                    }
                }

                //d3.select("#testbot").attr("cx", who.x).attr("cy", who.y);
                who.allowance = this.step;
                while (who.allowance > 0) {
                    who[who.icl[who.on][0]](who.icl[who.on][1]);
                }


            }
            if (!minAdded) {
                this.minSearched.push(this.minSearched[this.time]);
            }
            if (!maxAdded) {
                this.maxSearched.push(this.maxSearched[this.time]);
            }
            minAdded = false;
            maxAdded = false;
            for (var j = 0; j < this.mods.length; j++) {
                if (this.mods[j].Update) {
                    this.mods[j].Update();
                }
            }
            this.time++;
        }
        this.timeMax = this.history[0].length;
    }

}

/**
*A module for keep track of the number of points searched along a shapes path.
*Also doubles as drawing the worst case envelope.
*
*
*@param {iclData} iclData A reference to iclData that this module is enabled in.
*@param {Object} exit {x,y} coordinates to the exit location.
*@param {d3.SVG} field A d3 reference to the SVG used to display the main field.
*@param {d3.SVG} graph A d3 reference to the SVG used to display the main graph.

*/
class exitFindMod {
    constructor(iclData, exit, field) {
        /**Reference to iclData this module is enabled in.*/
        this.iclData = iclData;
        /**One step size.*/
        this.step = this.iclData.step;
        /**Pre-history AKA before exit was placed anywhere.*/
        this.premo = null;
        /**Exit location {x,y}*/
        //this.exit = exit;
        /**Array of termination times for each exit placement. Only gets points searched, otherwise they will be 0.*/
        this.exitDistances = [];
        /**D3 reference to the field.*/
        this.fieldSVG = field;
        /**D3 reference to the graph*/
        //this.graphSVG = graph;
        /**Array of graphlines showing distance from exit for each tourist.*/
        this.graphLines = [];
        /**Array of lines showing where tourist has travelled on field.*/
        this.tourlines = [null,  null];
    }

    Init() {
        /*
        if (this.iclData.history) {
            this.premo = this.iclData.history;
        }
        */
        for (var i = 0; i < this.iclData.tourists.length; i++) {
            this.exitDistances.push([]); // Add each array for tourists.
        }
    }

    Update() {
        var loc = this.iclData.history;
        var j = 0;
        for (var i = 0; i < this.iclData.tourists.length; i++) {

            var distance = Math.abs(this.iclData.exitLoc.x - this.iclData.tourists[i].x);
            //console.log("Distance " + this.iclData.tourists[i].number + ": " + distance);
            //this.exitDistances[i].push(distance);
            if (this.iclData.tourists[i].faulty) { // Faulty robot has 1% chance to break down
                if (Math.floor((Math.random() * 10000) + 1) > 9990) {
                    this.iclData.tourists[i].on = this.iclData.tourists[i].icl.length - 2;
                    console.log("broke down");
                    this.iclData.tourists[i].knows = true;
                    this.iclData.tourists[i].icl[0][0] = "#ffa500";

                }

            }
            if (distance <= this.step) {
                // If tourist is priority and at exit end alg by time = timeMax
                if (this.iclData.tourists[i].priority) {
                    this.iclData.allExitedLine = 1;
                    this.iclData.timeMax = this.iclData.time;
                }

                if (!this.iclData.tourists[i].knows) {
                    this.iclData.tourists[i].on = this.iclData.tourists[i].icl.length - 1;
                    this.iclData.tourists[i].knows = true;
                    this.iclData.tourists[i].target = null;
                    //this.iclData.tourists[i].x = this.iclData.exitLoc.x;
                    j++;
                }
                // Send out exit alert
                if (this.iclData.wireless && ! this.iclData.tourists[i].faulty) {
                    for (var m = 0; m < this.iclData.tourists.length; m++) {
                        this.iclData.tourists[m].on = this.iclData.tourists[m].icl.length - 1;
                        this.iclData.tourists[m].knows = true;
                    }
                }
            }

        }
        var allKnowing = false;
        for (var t = 0; t < this.iclData.tourists.length; t ++ ) {
            if (!this.iclData.tourists[t].faulty){
                allKnowing = utils.cmpXYPairs(this.iclData.tourists[t], this.iclData.exitLoc);
            }
            if (!allKnowing){
                break;
            }
        }
        if (allKnowing) {
            //console.log("AllKnowing")
            this.iclData.allKnowing = true;
            this.iclData.timeMax = this.iclData.time;
        }
    }
    /*

    VReset() {
        this.graphSVG.select("#backGround").html(null);

        this.graphSVG.select("#bots").html(null);
        this.graphSVG.select("#lines").html(null);
        this.graphSVG.select("#overLay").html(null);
        this.fieldSVG.select("#lines").html(null);
        this.fieldSVG.select("#overLay").html(null);
    }
    */


    UVInit() { // draw initial graph.
        this.VReset();
        for (var i = 0; i < this.iclData.tourists.length; i++) {
            this.graphLines.push([]);
        }
        this.fieldSVG.select("#lines").append("circle")
            .attr("cx", this.iclData.fieldExit.x)
            .attr("cy", this.iclData.fieldExit.y)
            .attr("r",  1)
            .attr("id", "exit")
            .style("fill", "#ffffff")
            .style("stroke", "#000000")
            .style("stroke-width", "0.1");

        this.graphSVG.select("#backGround").append("path")
            .attr("d", "M" + (0.4 * this.iclData.unit2Px) + "," + (1.5 * this.iclData.unit2Px) +
                       "L" + (0.4 * this.iclData.unit2Px) + "," + (3.55 * this.iclData.unit2Px) +
                       "L" + (3.5 * this.iclData.unit2Px) + "," + (3.55 * this.iclData.unit2Px))
            .style("stroke", "#000000")
            .style("stroke-width", 1)
            .style("fill", "none");

        this.graphSVG.select("#overLay").append("text")
            .attr("x", 15)
            .attr("y", 70)
            .attr("transform", "rotate(-90, 10, 75)")
            .style("fill", "#000000")
            .style("font-size", "5")
            .style("text-anchor", "middle")
            .text("Dist. from Exit (radius)");
        this.graphSVG.select("#overLay").append("text")
            .attr("x", 50)
            .attr("y", 98)
            .style("fill", "#000000")
            .style("font-size", "5")
            .style("text-anchor", "middle")
            .text("Time (seconds)");


        for (var i = 1; i < 3; i++) { //Create y-axis labels.
            this.graphSVG.select("#backGround").append("text")
                .attr("x", (0.3 * this.iclData.unit2Px))
                .attr("y", ((3.55 * this.iclData.unit2Px) - (i * this.iclData.unit2Px)))
                .style("font-size", this.iclData.unit2Px * (4 / 25))
                .style("text-anchor", "middle").text(i + 'r');
        }

        var mtime = Math.floor((1000 * this.iclData.timeMax) / this.iclData.fps) / 1000;

        for (var i = 0; i <= mtime; i++) { //Create new scaled x-axis labels.
            this.graphSVG.select("#backGround").append("text")
                .attr("x", (0.5 * this.iclData.unit2Px + i / mtime * 3 * this.iclData.unit2Px))
                .attr("y", this.iclData.unit2Px * 3.75)
                .style("font-size", this.iclData.unit2Px * (4 / 25))
                .style("text-anchor", "middle")
                .text(i)
                .attr("class", "graphnum");
        }

        var touristCount = 0;
        outer:
            for (var i = 0; i <= 2; i++) {
                if (touristCount + 1 == this.iclData.instruBinder.length) {
                    break outer;
                }
                for (var j = 0; j <= 2; j++) {
                    this.graphSVG.select("#overLay").append("circle")
                        .attr("cx", (2 * this.iclData.unit2Px) + (j * (2 / 3 * this.iclData.unit2Px)))
                        .attr("cy", (this.iclData.unit2Px * 0.15) + (i * (1 / 5 * this.iclData.unit2Px)))
                        .attr("r", this.iclData.unit2Px / 16)
                        .style("fill", this.iclData.tourists[touristCount].icl[0][0])
                        .style("stroke", "#ffffff")
                        .style("stroke-width", (1 / 100 * this.iclData.unit2Px));
                        /* If svg text wants to play nice this can come back out.
                        .on("mouseover", function(d) { //temporary function to show ICL on mouseover.
                            var botInfo = d3.select(this).style("stroke", "black");
                            botInfo = d3.select(this.parentNode);
                            console.log(d3.select(this))
                            botInfo.select("#icl")
                                .attr("x", d3.select(this).attr("cx"))
                                .attr("y", d3.select(this).attr("cy") - (4/25))
                                .text("Hello " + touristCount)
                                .style("opacity", 1.0);
                        })
                        .on("mouseout", function(d) { // hide icl on mouseout
                            var botInfo = d3.select(this).style("stroke", "white");
                            botInfo = d3.select(this.parentNode);
                            botInfo.select("#icl").style("opacity", 0.0);
                        });
                        */
                    this.graphSVG.select("#overLay").append("text")
                        .attr("x", (2 * this.iclData.unit2Px) + (this.iclData.unit2Px / 15) + (j * (2 / 3 * this.iclData.unit2Px)))
                        .attr("y", (this.iclData.unit2Px * 0.15) + (this.iclData.unit2Px / 32) + (i * (1 / 5 * this.iclData.unit2Px)))
                        .style("font-size", this.iclData.unit2Px * (3 / 25))
                        .text("" + ((this.iclData.tourists[touristCount].icl[0][1] === true) ? "Queen " + touristCount : " Bot " + touristCount));

                    if (touristCount + 1 == this.iclData.instruBinder.length) {
                        break outer;
                    }
                    touristCount++;

                }
            }
    }

    UVUpdate() {
        var formatvalue = d3.format(",.3f");

        var hold = '';
        for (var i = 0; i < this.iclData.tourists.length; i++) {
            var hold = '';

            if (this.iclData.time > 0) {
                this.graphLines[i].remove();
                this.tourlines[i].remove();
            }
            for (var j = 0; j < this.iclData.time; j++) {
                var pt = {
                    x: (0.5 * this.iclData.unit2Px) + (3 * this.iclData.unit2Px * (j / this.iclData.timeMax)),
                    y: (3.55 * this.iclData.unit2Px) - this.exitDistances[i][j]
                };
                hold += ((j == 0) ? ('M') : ('L')) + pt.x + ',' + pt.y;

            }
            this.graphLines[i] = this.graphSVG.select("#lines").append("path")
                .attr("d", hold)
                .attr("stroke-width", 1)
                .attr("id", "graphlines")
                .style("stroke", this.iclData.tourists[i].icl[0][0] )
                .style("fill", "none")
                .style("opacity", 0.5);

            var tourlineHold = "";
            if (this.tourlines[i]) {
                this.tourlines[i].remove();
                this.tourlines[i] = null;
            }
            for (var s = 0; s < this.iclData.time; s++) {
                var pt = {
                    x: this.iclData.history[i][s].x,
                    y: this.iclData.history[i][s].y
                };
                tourlineHold += ((s == 0) ? ('M') : ('L')) + pt.x + ',' + pt.y;

            }
            this.tourlines[i] = this.fieldSVG.select("#lines").append("path")
                .attr("d", tourlineHold)
                .attr("stroke-width", 1)
                .attr("id", "tourlines")
                .style("stroke", this.iclData.tourists[i].icl[0][0])
                .style("fill", "none")
                .style("opacity", 0.5);
        }


    }
}
/**
*A module for keep track of the number of points searched along a shapes path.
*Also doubles as drawing the worst case envelope.
*
*
*@param {iclData} iclData A reference to iclData that this module is enabled in.
*@param {d3.SVG} exitEnvelopeGraph A d3 reference to the SVG used to display the worst case graph.
*/

class lineFillMod {
    constructor(iclData, exitEnvelopeGraph) {
        /**Reference to the instance of iclData this module is enabled in.*/
        this.iclData = iclData;
        /**One step size.*/
        this.step = this.iclData.unit2Px / this.iclData.fps;
        /**List of points. A copy of iclData.pPath*/
        this.pts = null;
        /**Points searched. Decrements with each one searched.*/
        this.count = -1;
        /***/
        //this.tourlines = [null, null];
        /**List of termination times based on exit location.*/
        this.exitTimes = [];
        /**D3 Reference to exit envelope graph.*/
        this.exitEnvelopeGraph = exitEnvelopeGraph;
        /**D3 reference to the exit envelope line drawn at the end.*/
        this.exitEnvelopeLine = null;
        /**List of points travelled by tourists so we can draw a time graph*/
        this.timePoints = [];
        /**The full length of the timeline by the number of steps taken total*/
        this.timeStep = this.iclData.pathLength / this.iclData.timeMax;
    }

    Init() {
        this.pts = this.iclData.pPath.slice();
        this.count = this.iclData.pPath.length;
        for (var p = 0; p < this.pts.length; p++) {
            this.exitTimes.push(0);
        }


    }

    Update() {
        var loc = this.iclData.history;
        for (var i = 0; i < loc.length; i++) {
            for (var j = 0; j < this.pts.length; j++) {
                if (this.pts[j]) {
                    var distance = Math.hypot(
                        this.pts[j].y - loc[i][loc[i].length - 1].y,
                        this.pts[j].x - loc[i][loc[i].length - 1].x
                    );
                    if (distance <= this.step / 2) {
                        this.pts[j] = null;
                        this.count--;
                        this.exitDistChecker(i, j);
                    }
                }
            }
        }
        if (this.count < 1) {
            this.iclData.timeMax = this.iclData.time;
        }
    }

    // For checking priority end times only. Does not work on normal or F2F algorithms!
    exitDistChecker(i, j){
        if (this.iclData.tourists[i].priority) {
            this.exitTimes[j] = (Math.floor((1000 * this.iclData.time) / this.iclData.fps) / 1000);
        }
        else {
            // Helper is tourist i
            var posHold = [];
            var distHold = [];
            for (var t = 0; t < this.iclData.tourists.length; t++) {
                if (t != i) {
                    posHold.push({x:this.iclData.tourists[t].x, y:this.iclData.tourists[t].y});
                    var dVec = {
                        x:Math.abs(this.iclData.tourists[i].x - this.iclData.tourists[t].x),
                        y:Math.abs(this.iclData.tourists[i].y - this.iclData.tourists[t].y)
                    }
                    distHold.push(Math.hypot(dVec.y, dVec.x));
                }
            }
            this.exitTimes[j] = (Math.floor((1000 * this.iclData.time) / this.iclData.fps) / 1000) + (Math.min(...distHold) / this.iclData.unit2Px);

        }
    }

    VReset() {
        this.exitEnvelopeGraph.select("#backGround").html(null);
        this.exitEnvelopeGraph.select("#lines").html(null);
        this.exitEnvelopeGraph.select("#bots").html(null);
        this.exitEnvelopeGraph.select("#overLay").html(null);
    }

    VInit() {
        this.VReset();
        this.exitEnvelopeGraph.select("#lines").append("path")
            .attr("d", "M" + (0.4 * this.iclData.unit2Px) + "," + (1.55 * this.iclData.unit2Px) +
                       "L" + (0.4 * this.iclData.unit2Px) + "," + (3.55 * this.iclData.unit2Px) +
                       "L" + (3.5 * this.iclData.unit2Px) + "," + (3.55 * this.iclData.unit2Px))
            .style("stroke", "#000000")
            .style("stroke-width", 1)
            .style("fill", "none");

        for (var i = 0; i < (Math.floor((1000 * this.iclData.timeMax) / this.iclData.fps) / 1000)+1; i++) { //Create y-axis labels.
            this.exitEnvelopeGraph.select("backGround").append("text")
                .attr("x", (0.3 * this.iclData.unit2Px))
                .attr("y", ((3.55 * this.iclData.unit2Px) - (i * 0.5 *this.iclData.unit2Px)))
                .style("font-size", this.iclData.unit2Px * (4 / 25))
                .style("text-anchor", "middle").text(i + 's');
        }

        for (var i = 0; i < 7; i ++){
            this.exitEnvelopeGraph.select("#backGround").append("text")
                .attr("x", (0.5 * this.iclData.unit2Px) + (3 * this.iclData.unit2Px * ((i * 60) / 360)))
                .attr("y", (3.75 * this.iclData.unit2Px))
                .style("font-size", this.iclData.unit2Px * (4 / 25))
                .text((i * 60) + "°");

        }
        var graphName = this.exitEnvelopeGraph.select("#backGround").append("text")
            .attr("x", this.iclData.unit2Px * 2)
            .attr("y", this.iclData.unit2Px * 0.5)
            .style("font-size", 0.12 * this.iclData.unit2Px)
            .style("text-anchor", "middle")
            .text("Time until evacuation condition for each searched point this run");

    }

    VUpdate() {
        var formatvalue = d3.format(",.3f");
        var hold = '';
        if (this.iclData.time > 0) {
            this.exitEnvelopeLine.remove();
        }
        for (var j = 0; j < this.exitTimes.length - 1; j++) {
            var pt = {
                x: (0.5 * this.iclData.unit2Px) + (3 * this.iclData.unit2Px * (j / this.exitTimes.length)),
                y: (3.55 * this.iclData.unit2Px) - (this.exitTimes[j] * 0.5  *this.iclData.unit2Px)
            };
            hold += ((j == 0) ? ('M') : ('L')) + pt.x + ',' + pt.y;

        }

        if (this.iclData.time == this.iclData.timeMax - 1){
            var exitMax = this.exitEnvelopeGraph.select("#backGround").append("text")
                .attr("x", this.iclData.unit2Px * 2)
                .attr("y", this.iclData.unit2Px)
                .style("font-size", 0.2 * this.iclData.unit2Px)
                .style("text-anchor", "middle")
                .text("Max time taken: " + formatvalue(Math.max(...this.exitTimes)));
            var worstPlacement = this.exitEnvelopeGraph.select("#backGround").append("text")
                .attr("x", this.iclData.unit2Px * 2)
                .attr("y", this.iclData.unit2Px * 1.2)
                .style("font-size", 0.2 * this.iclData.unit2Px)
                .style("text-anchor", "middle")
                .text("Worst Exit Placement: " + (this.exitTimes.indexOf(Math.max(...this.exitTimes))) / 2 + "°");
        }

        this.exitEnvelopeLine = this.exitEnvelopeGraph.select("#lines").append("path")
            .attr("d", hold)
            .attr("stroke-width", 1)
            .style("stroke", "00ff00")
            .style("fill", "none");


    }

}

/*
Module to graph the upper bound of exit times based on algorithm.
*/

/**
 *All visual updates and d3 calls for the sim happen in this.
 *Rests on top of an instance of iclData.
 *Field: The Shape, usually the left panel.
 *Graph: The distance from exit graph, usually LoadPointsthe right panel.
 *Multiple instances can and will be used for algorithm comparisons.
 *
 * @param {iclData} iclData The values necessary to update the visuals.
 * @param {d3.SVG} field d3 instance of our main field SVG.
 * @param {d3.SVG} graph d3 instance of our main graph SVG.
 *

 */

class iclVisual {
    constructor(iclData, field) {
        /** An instance of iclData to use to update visuals */
        this.iclData = iclData;
        /** A D3 reference to the Field. Contains 4 Layers - 1: BackGround, 2: Lines, 3: Bots, 4: OverLay */
        this.fieldSVG = field;
        //this.fieldSVG = d3.select("#anim" + this.iclData.id);
        /** A D3 reference to the movable time slider that appears at the end of a normal sim. */
        this.timeSlider;
        /** A D3 reference to the text which shows the current time in the sim (seconds). */
        this.timeText;
        /** A D3 reference to the text which shows the current time in the sim (frames). */
        this.frameText;
        /** A reference to a D3 line function to create valid lines out of strings. */
        this.lineFx = d3.line().x((d) => {
            return (d.x);
        }).y((d) => {
            return (d.y);
        });
        this.visuals = [];
        this.connections = [];
        this.maxSearchedLine = null;
        this.minSearchedLine = null;
        this.done = false;
        this.tourlines = [null, null];
        this.timeStep = this.iclData.pathLength / this.iclData.timeMax;
        this.origin = 35;
        this.timeLines = [];
        this.timeHold = [];
        this.exitTimeText = null;
        this.Init();
    }


    Init() {
        this.iclData.time = 0;
        /*
        var hold = '';
        for (var i = 0; i < this.iclData.path.length; i++) {
            var pt = this.iclData.path[i];
            hold += ((i == 0) ? ('M') : ('L')) + pt.x + ',' + pt.y;
        }
        this.fieldSVG.select("#lines").append("path")
            .attr("d", hold).attr("stroke-width", 0.25)
            .style("stroke", "000000").style("fill", "none");
        */

        for (var i = 0; i < this.iclData.history.length; i++) {
            this.visuals.push(this.fieldSVG.select("#bots").append("circle")
                .attr("r", 1.5)
                .attr("cx", this.iclData.start.x)
                .attr("cy", this.iclData.start.y)
                .attr("stroke-width", 0.25)
                .style("fill", this.iclData.tourists[i].icl[0][0] )
                .style("stroke", "none")
            );
            this.connections.push(this.fieldSVG.select("#lines").append("line")
                .attr("x1", this.iclData.origin.x)
                .attr("y1", this.iclData.origin.y)
                .attr("x2", this.visuals[i].attr("cx"))
                .attr("y2", this.visuals[i].attr("cy"))
                .style("stroke-width", 0.25)
                .style("stroke", this.iclData.tourists[i].icl[0][0] )
                .style("fill", "none")
            );
            this.minSearchedLine = (this.fieldSVG.select("#lines").append("line")
                .attr("x1", this.iclData.origin.x)
                .attr("y1", this.iclData.origin.y)
                .attr("x2", this.iclData.minSearched[this.iclData.time])
                .attr("y2", 35)
                .style("stroke-width", 0.25)
                .style("stroke", "black" )
                .style("fill", "none")
            );
            this.maxSearchedLine = (this.fieldSVG.select("#lines").append("line")
                .attr("x1", this.iclData.origin.x)
                .attr("y1", this.iclData.origin.y)
                .attr("x2", this.iclData.maxSearched[this.iclData.time])
                .attr("y2", 35)
                .style("stroke-width", 0.25)
                .style("stroke", "black" )
                .style("fill", "none")
            );
            this.timeLines.push(null);
            this.timeHold.push("");
        }

        for (var i = 0; i < this.iclData.mods.length; i++) {
            if (this.iclData.mods[i].VInit) {
                this.iclData.mods[i].VInit();
            }
        }
        var negativetext = this.fieldSVG.select("#negativetext")
            .text(this.iclData.points / -2);

        var positivetext = this.fieldSVG.select("#positivetext")
            .text(this.iclData.points / 2);
        var exitText = this.fieldSVG.select("#exittext")
            .attr("x", this.iclData.exitLoc.x)
            .attr("y", this.iclData.exitLoc.y - 3)
            .style("font-size", 2)
            .style("text-anchor", "middle")
            .text("Exit: " + this.iclData.exit + " units");
        var exitTick = this.fieldSVG.select("#backGround").append("line")
            .attr("x1", this.iclData.exitLoc.x)
            .attr("y1", this.iclData.origin.y - 1)
            .attr("x2", this.iclData.exitLoc.x)
            .attr("y2", this.iclData.origin.y + 1)
            .style("stroke", "black")
            .style("stroke-width", 0.25)
            .style("fill", "none");
        var miniTicks = [];
        for (var t = 0; t < this.iclData.points / 2; t += this.iclData.points / 8){
            miniTicks.push(this.fieldSVG.select("#backGround").append("line")
                .attr("x1", this.iclData.center.x + (this.iclData.unit2Px * t))
                .attr("y1", this.iclData.center.y - 1)
                .attr("x2", this.iclData.center.x + (this.iclData.unit2Px * t))
                .attr("y2", this.iclData.center.y)
                .style("stroke", "grey")
                .style("stroke-width", 0.1)
                .style("fill", "none")
            )
            this.fieldSVG.select("#backGround").append("text")
                .attr("x", this.iclData.center.x + this.iclData.unit2Px * t)
                .attr("y", this.iclData.center.y - 2)
                .style("fill", "grey")
                .style("font-size", 1)
                .style("text-anchor", "middle")
                .text(Math.round( t * 10 ) / 10);
        }
        for (var t = 0; t > -this.iclData.points/2; t -= this.iclData.points / 8){
            miniTicks.push(this.fieldSVG.select("#backGround").append("line")
                .attr("x1", this.iclData.center.x + (this.iclData.unit2Px * t))
                .attr("y1", this.iclData.center.y - 1)
                .attr("x2", this.iclData.center.x + (this.iclData.unit2Px * t))
                .attr("y2", this.iclData.center.y)
                .style("stroke", "grey")
                .style("stroke-width", 0.1)
                .style("fill", "none")
            )
            this.fieldSVG.select("#backGround").append("text")
                .attr("x", this.iclData.center.x + this.iclData.unit2Px * t)
                .attr("y", this.iclData.center.y - 2)
                .style("fill", "grey")
                .style("font-size", 1)
                .style("text-anchor", "middle")
                .text(Math.round( t * 10 ) / 10);
        }
        var speedtext = this.fieldSVG.select("#speedtext")
            .style("font-size", 2.5)
            .text("Speed: " + this.iclData.animSpeed + "x");

        /*
        this.timeSlider = this.graphSVG.select("#overLay").append("rect").attr("width", this.iclData.unit2Px / 15).attr("height", this.iclData.unit2Px * 2)
            .attr("y", this.iclData.unit2Px * 1.55).attr("x", this.iclData.unit2Px * (10 / 25))
            .style("fill", "#888888").style("fill-opacity", .5)
            .call(d3.drag().on("start", this.SSlide).on("drag", (function(self) {
                return function() {
                    self.MSlide();
                }
            })(this)).on("end", this.ESlide)).attr("class", "timeSlide" + this.iclData.id);
        */
        /*
        this.timeText = this.graphSVG.select("#overLay").append("text").attr("x", this.iclData.unit2Px * (1 / 25)).attr("y", this.iclData.unit2Px * .15)
            .style("font-size", this.iclData.unit2Px * (4 / 25)).style("text-anchor", "start").text("Time: 0").attr("class", "timeText");
        this.frameText = this.graphSVG.select("#overLay").append("text").attr("x", this.iclData.unit2Px * (1 / 25)).attr("y", this.iclData.unit2Px * .35)
            .style("font-size", this.iclData.unit2Px * (4 / 25)).style("text-anchor", "start").text("Frame: 0").attr("class", "frameText");
        var exitPlacement = this.graphSVG.select("#overLay").append("text")
            .attr("x", this.iclData.unit2Px * 0.04)
            .attr("y", this.iclData.unit2Px * 0.55)
            .style("font-size", 0.16 * this.iclData.unit2Px)
            .text("Exit Placement: " + this.iclData.exitAngle + "°");

        this.graphSVG.select("#overLay").append('text').attr("x", this.iclData.unit2Px * (1 / 25)).attr("y", this.iclData.unit2Px * 0.75).text(' ▶▶ Play').style('font-size', this.iclData.unit2Px * 4 / 25).attr('fill', 'green')
            .attr('class', 'reveal play').style('box-sizing', 'border-box').attr('cursor', 'pointer').on('click', () => {
                this.iclData.timeDirect++;
            });
        this.graphSVG.select("#overLay").append('text').attr("x", this.iclData.unit2Px * (1 / 25)).attr("y", this.iclData.unit2Px * 0.95).text(' ■ Stop').style('cursor', 'pointer').style('font-size', this.iclData.unit2Px * 4 / 25).attr('fill', 'red')
            .attr('class', 'reveal play').on('click', () => {
                this.iclData.timeDirect = 0;
            });
        this.graphSVG.select("#overLay").append('text').attr("x", this.iclData.unit2Px * (1 / 25)).attr("y", this.iclData.unit2Px * 1.15).text(' ◀◀ Rewind').style('cursor', 'pointer').style('font-size', this.iclData.unit2Px * 4 / 25).attr('fill', 'blue')
            .attr('class', 'reveal play').on('click', () => {
                this.iclData.timeDirect--;
            });
        */

    }

    static reEnact() {
        if (!this.done && this.iclData.time < this.iclData.timeMax) {
            for (var i = 0; i < this.iclData.history.length; i++) {
                if (this.iclData.history[i][this.iclData.time].x > this.iclData.maxPx) {
                    this.visuals[i].attr("cx", this.iclData.maxPx);
                    d3.select("#overflow" + i).remove();
                    this.fieldSVG.select("#bots").append("text")
                        .attr("x", this.visuals[i].attr("cx"))
                        .attr("y", this.iclData.origin.y + (4 * (i+1)))
                        .attr("id", "overflow" + i)
                        .style("fill", this.iclData.tourists[i].icl[0][0])
                        .style("font-size", 1.5)
                        .style("text-anchor", "middle")
                        .text( "+ " + Math.floor((this.iclData.history[i][this.iclData.time].x - this.iclData.maxPx) * 10) / 10);
                }
                else if (this.iclData.history[i][this.iclData.time].x < this.iclData.minPx) {
                    d3.select("#overflow" + i).remove();
                    this.visuals[i].attr("cx", this.iclData.minPx);
                    console.log(this.iclData.center.y)
                    this.fieldSVG.select("#bots").append("text")
                        .attr("x", this.visuals[i].attr("cx"))
                        .attr("y", this.iclData.center.y + (4 * (i+1)))
                        .attr("id", "overflow" + i)
                        .style("fill", this.iclData.tourists[i].icl[0][0])
                        .style("font-size", 1.5)
                        .style("text-anchor", "middle")
                        .text( Math.floor((this.iclData.history[i][this.iclData.time].x - this.iclData.minPx) * 10) / 10);
                }
                else {
                    d3.select("#overflow" + i).remove();
                    this.visuals[i].attr("cx", this.iclData.history[i][this.iclData.time].x)
                        .attr("cy", this.iclData.history[i][this.iclData.time].y);
                }
                if (this.iclData.time > 0) {
                    this.timeLines[i].remove();
                    this.timeHold[i].remove();
                }
                this.timeLines[i] = this.fieldSVG.select("#lines").append("line")
                    .attr("x1", this.iclData.history[i][this.iclData.time].x)
                    .attr("y1", this.iclData.tourists[i].y)
                    .attr("x2", this.iclData.history[i][this.iclData.time].x)
                    .attr("y2", this.iclData.origin.y + this.timeStep * this.iclData.time)
                    .style("stroke-width", 0.75)
                    .style("stroke", this.iclData.tourists[i].icl[0][0])
                    .style("fill", "none");
                this.timeHold[i] = this.fieldSVG.select("#lines").append("circle")
                    .attr("cx", this.iclData.history[i][this.iclData.time].x)
                    .attr("cy", this.iclData.origin.y + this.timeStep * this.iclData.time)
                    .attr("r",  0.75)
                    .style("fill", this.iclData.tourists[i].icl[0][0])
                    .style("stroke", "none");

/*
                if (this.iclData.time % 4 == 0) {
                    if (this.iclData.time > 0) {
                        this.timeLines[i].remove();
                    }
                    var pt = {
                        x: this.iclData.history[i][this.iclData.time].x,
                        y: this.iclData.origin.y + this.timeStep * this.iclData.time
                    }
                    if (pt.x > this.iclData.maxPx) {
                        pt.x = this.iclData.maxPx;
                    }
                    else if (pt.x < this.iclData.minPx) {
                        pt.x = this.iclData.minPx;
                    }
                    this.timeHold[i] += ((this.iclData.time == 0) ? ('M') : ('L')) + pt.x + ',' + pt.y;
                    this.timeLines[i] = this.fieldSVG.select("#lines").append("path")
                        .attr("d", this.timeHold[i])
                        .attr("stroke-width", 0.75)
                        .style("stroke", this.iclData.tourists[i].icl[0][0])
                        .style("stroke-linejoin", "round")
                        .style("fill", "none");
                }
*/

            /* Connections and min/maxsearched lines
                this.connections[i]
                .attr("x2", this.iclData.history[i][this.iclData.time].x)
                .attr("y2", this.iclData.history[i][this.iclData.time].y);
                this.minSearchedLine
                .attr("x2", this.iclData.minSearched[this.iclData.time]);
                this.maxSearchedLine
                .attr("x2", this.iclData.maxSearched[this.iclData.time]);
            */
                if (this.visuals[i].attr("cx") == this.iclData.exitLoc.x && !this.exitTimeText) {
                    this.exitTimeText = this.fieldSVG.select("#timetext")
                        .attr("x", 90)
                        .attr("y", this.origin)
                        .style("font-size", 2)
                        .style("text-anchor", "middle")
                        .text("Exit found at " + Math.floor((1000 * this.iclData.time * this.iclData.animSpeed ) / this.iclData.fps) / 1000);
                }


            }
            this.fieldSVG.select("#totaltime")
                .text("Time: " + Math.floor((1000 * this.iclData.time* this.iclData.animSpeed) / this.iclData.fps) / 1000);
            this.origin += this.timeStep;
            this.fieldSVG.select("#origin").attr("cy", this.origin);


            for (var i = 0; i < this.iclData.mods.length; i++) {
                if (this.iclData.mods[i].VUpdate) {
                    this.iclData.mods[i].VUpdate();
                }
            }

            /*
            this.timeText.text("Time: " + Math.floor((1000 * this.iclData.time) / this.iclData.fps) / 1000);
            this.frameText.text("Frame: " + this.iclData.time);
            this.timeSlider.attr("x", (0.45 * this.iclData.unit2Px) + (3 * this.iclData.unit2Px * (this.iclData.time / this.iclData.timeMax)));
            */
            this.iclData.time += this.iclData.timeDirect;
            return;
        }

        else {
            if (!this.done) {
                this.done = true;
                this.fieldSVG.select("#terminationtext")
                    .attr("x", 50)
                    .attr("y", this.origin + 4)
                    .style("font-size", 2)
                    .style("text-anchor", "middle")
                    .text("Algorithm terminates at " + Math.floor((1000 * (this.iclData.time - 1) * this.iclData.animSpeed ) / this.iclData.fps) / 1000);
            }
            /*
            if (!this.done){
                this.iclData.time = this.iclData.timeMax;
                this.iclData.timeDirect = 0;
                this.done = true;
            }

            for (var i = 0; i < this.iclData.history.length; i++) {
                this.visuals[i].attr("cx", this.iclData.history[i][this.iclData.time].x)
                    .attr("cy", this.iclData.history[i][this.iclData.time].y);
            }

            this.timeText.text("Time: " + Math.floor((1000 * this.iclData.time) / this.iclData.fps) / 1000);
            this.frameText.text("Frame: " + this.iclData.time);
            this.timeSlider.attr("x", (0.45 * this.iclData.unit2Px) + (3 * this.iclData.unit2Px * (this.iclData.time / this.iclData.timeMax)));
            if (this.iclData.time + this.iclData.timeDirect < 0) {
                this.iclData.time = 0;
                this.iclData.timeDirect = 0;
            }
            else if (this.iclData.time + this.iclData.timeDirect >= this.iclData.timeMax){
                this.iclData.time = this.iclData.timeMax;
                this.iclData.timeDirect = 0;
            }
            else{
                this.iclData.time += this.iclData.timeDirect;
            }
            */
        }
    }



}
