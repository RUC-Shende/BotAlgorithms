<!doctype html>

<html>
  <head>
    <!--<script src = "https://d3js.org/d3.v5.min.js"></script>-->
    <script src = "d3.min.js"></script>
  </head>
  <body>
    <h1>Evacuate Room</h1>
    <p>Circle Room</p>
    <script>
      //Learning Jupiter NoteBook
      //////////----------Instantiate Variables----------//////////
      var loading = true;

      var time = 0;
      var timeMax = 10000;
      var timeBox;
      var timeSlide;

      var fxs = [this.GoOutAtAngle, this.FollowWall, this.FollowWallFor, this.GoToCenter,
                 this.Wait, this.WaitFor, this.AverageWait];
      var projector;
      var fieldSVG;
      var unit2Px = 0;
      var center = [0, 0];
      var fps = 120;
      var touristNum = 0;
      var tourists = [];

      var fieldExit = 0;
      var wireless = true;
      var instruBinder = [
                          [[0, [30]], [1, ["left"]]],
                          [[0, [330]], [1, ["right"]]],
                          [[0, [30]], [2, ["right", 60]], [3, [null]], [5, [1]], [6, [null]]],
                         ];

      //////////---------- Instantiate Classes ----------//////////
      class Tourist {
        constructor (visual, instructions, center) {
          this.number = touristNum;
          touristNum++;
          this.visual = visual;
          this.instru = instructions;
          this.a = 0;
          this.x = center[0];
          this.y = center[1];
          this.t = 0;
          this.on = 0;
          this.velocity = unit2Px;
          this.stamps = [[null, center[0], center[1]]];
          this.ikwei = false;
        }
        Update() {
          if (!this.ikwei) {
            fxs[this.instru[this.on][0]](this, this.instru[this.on][1]);
            FoundExit(this);
          }
        }
      }

      //////////--------Instantiate Call Functions--------//////////
      function SSlide() {
        d3.select(this).style("fill", "orange");
        d3.select(this).classed("active", true);
      }

      function MSlide(d) {
        var mousePos = d3.event.x;
        if (mousePos < 0) {
          mousePos = 0;
        } else if (mousePos > (31 / 8) * unit2Px) {
          mousePos = (31 / 8) * unit2Px;
        }
        d3.select(this).attr("x", mousePos);
      }

      function ESlide() {
        d3.select(this).style("fill", "#888888");
        d3.select(this).classed("active", false);
      }
      //////////----------Instantiate Functions----------//////////

//0	Start/Mid function; Requires robot at center and an angle, robot goes from some angle for one radius.
      function GoOutAtAngle(who, value) {
        var distance = Math.sqrt(Math.pow(center[0] - who.x, 2) + Math.pow(center[1] - who.y, 2));
        who.a = value[0] * (Math.PI / 180);
        if (distance < unit2Px) {
          who.x = who.x + Math.cos(who.a) * (unit2Px / fps);
          who.y = who.y + Math.sin(who.a) * (unit2Px / fps);
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else if (loading) {
          who.stamps.push([time, who.a, who.x, who.y]);
          who.on++;
        }
      }

//1	Ending function; Requires robot at wall and direction, robot follows wall until exit is known.
      function FollowWall(who, value) {
        var change = ((value[0] == "left") ? (1) : (-1)) / fps;
        who.a += change;
        who.x = center[0] + unit2Px * Math.cos(who.a);
        who.y = center[1] + unit2Px * Math.sin(who.a);
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//2	Mid function; Requires robot at wall, angle(time) and direction, robot follow walls until angle(time) reached.
      function FollowWallFor(who, value) {
        if (Math.abs(who.a - who.stamps[who.on - 1][0]) < value[1] * (Math.PI / 180)) {
          var change = ((value[0] == "left") ? (1) : (-1)) / fps;
          who.a += change;
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] + unit2Px * Math.sin(who.a);
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else if (loading) {
          who.stamps.push([time, who.a, who.x, who.y]);
          who.on++;
        }
      }

//3	Mid function; Requires robot not at center, robot returns to center.
      function GoToCenter(who, value) {
        var distance = Math.sqrt(Math.pow(center[0] - who.x, 2) + Math.pow(center[1] - who.y, 2));
        if (distance > .1) {
          who.x = who.x - Math.cos(who.a) * (unit2Px / fps);
          who.y = who.y - Math.sin(who.a) * (unit2Px / fps);
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else if (loading) {
          who.stamps.push([time, who.a, who.x, who.y]);
          who.on++;
        }
      }

//4	Ending Function; Requires nothing, robot is waiting....
      function Wait(who, value) {
        console.log("waiting...");
      }

//5	Start/Mid function; Requires time, robot wait for some amount of time...
      function WaitFor(who, value) {
        if (who.t < value[0]) {
          who.t += (1 / fps);
        } else if (loading) {
          who.stamps.push([time, who.a, who.x, who.y]);
          who.t = 0;
          who.on++;
        }
      }

//6	Ending function;
      function AverageWait(who, value) {
        var avgX = 0;
        var avgY = 0;
        var count = 0;
        for (i = 0; i < tourists.length; i++) {
          if (i != who.number) {
            count++;
            avgX += tourists[i].x;
            avgY += tourists[i].y;
          }
        }
        avgX /= count;
        avgY /= count;
        var dX = avgX - who.x;
        var dY = avgY - who.y;
        var dA = Math.atan2(dY, dX);
        var distance = Math.sqrt(Math.pow(dX, 2) + Math.pow(dY, 2));
        if (distance > (unit2Px / fps)) {
          who.x = who.x + Math.cos(dA) * (unit2Px / fps);
          who.y = who.y + Math.sin(dA) * (unit2Px / fps);
        } else {
          who.x = who.x + Math.cos(dA) * distance;
          who.y = who.y + Math.sin(dA) * distance;
        }
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//Approximation; Checks if exit is reached.
      function FoundExit(who) {
        var distance = Math.sqrt(Math.pow(fieldExit[0] - who.x, 2) + Math.pow(fieldExit[1] - who.y, 2));
        if (distance <= .2) {
          who.ikwei = true;
        }
      }

//Initializes the viewing area.
      function Start() {
        unit2Px = (window.innerHeight <= window.innerWidth) ? (window.innerHeight / 5) : (window.innerWidth / 5);
        center = [unit2Px * 2, unit2Px * 2];
        fieldSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4).style("border", "1px solid black");
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px).style("fill-opacity", 0.0).style("stroke", "#000000");
        for (i = 0; i < instruBinder.length; i++) {
          tourists.push(new Tourist(fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px / 16).style("fill", "red"), instruBinder[i], center));
        }
        fieldExit = [center[0] + unit2Px * Math.cos(fieldExit * (Math.PI / 180)), center[1] + unit2Px * Math.sin(fieldExit * (Math.PI / 180))];
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", 1).style("fill", "#000000");
        timeBox = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8).style("fill-opacity", 0.0).style("stroke", "#000000");
        timeSlide = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                    .attr("visibility", "hidden").style("fill", "#888888")
                    .call(d3.drag().on("start", SSlide).on("drag", MSlide).on("end", ESlide));
        projector = setInterval(LoadAnim, 1000 / fps);
      }

//Wraps around AnimFrame, used to precalculate everything so the user can see the data.
      function LoadAnim() {
        if (time > timeMax) {
          timeSlide.attr("visibility", "visible");
          loading = false;
        }
        AnimFrame();
        timeBox.attr("width", (32 / 8) * unit2Px * (time / timeMax));
      }

//Updates bots;
      var AnimFrame = () => {
        if (time > timeMax) {
          clearInterval(projector);
        } else {
          time += (1000 / fps);
          timeSlide.attr("x", (31 / 8) * unit2Px * (time / timeMax));
          tourists.forEach((tourist) => {
                       tourist.Update();
                   });
        }
      };


      //////////----------Initial Function Call----------//////////
      Start();

    </script>
  </body>
</html>
