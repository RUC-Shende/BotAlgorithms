<!doctype html>

<html>
  <head>
    <!--<script src = "https://d3js.org/d3.v5.min.js"></script>-->
    <script src = "d3.min.js"></script>
  </head>
  <body>
    <script>
      //////////----------Instantiate Variables----------//////////
      var fxs = [GoOutAtAngle, Wait, FollowWall, WaitFor, FollowWallFor, GoToCenter, WaitAverage];

      var loading = true;
      var time = 0;
      var fps = 60;
      var timeMax = 10 * fps;

      var timeBox;
      var timeSlide;
      var timePlay;
      var timePause;
      var timeRewind;

      var projector;
      var fieldSVG;
      var unit2Px = ((window.innerHeight <= window.innerWidth) ?
                    (window.innerHeight) : (window.innerWidth)) / 5;
      var center = [unit2Px * 2, unit2Px * 2];
      var touristNum = 0;

      var selectDown;
      var selectText;
      var selectUp;

      var tourColors = [];
      var tourists = [];

      var graphSVG;
      var graphDots = [];

      var lineFx = d3.line().x((d) => {return(d.x);}).y((d) => {return(d.y);});
      var tourLines = [];
      var tourLine = [];
      var graphLines = [];
      var graphLine = [];

      var exitAngle = 0;
      var fieldExit = [center[0] + unit2Px, center[1]];
      var wireless = true;
      var instruBinder = [
                          [[0, [45]], [3, [1]], [5, [null]], [0, [225]], [4, ["left", 90]], [2, ["right"]]],
                          [[0, [-45]], [3, [1]], [5, [null]], [0, [135]], [4, ["right", 90]], [1, [null]]],
                          [[6, [null]]]
                         ];

      //////////--------Instantiate Call Functions--------//////////
//Drag function, updates tourists and graph dots relative to lines
      function SSlide() {
        d3.select(this).style("fill", "orange");
        d3.select(this).classed("active", true);
      }

      function MSlide() {
        var mousePos = d3.event.x;
        if (mousePos < 0) {
          mousePos = 0;
        } else if (mousePos > (31 / 8) * unit2Px) {
          mousePos = (31 / 8) * unit2Px;
        }
        d3.select(this).attr("x", mousePos);
        time = Math.round((mousePos / ((31 / 8) * unit2Px)) * timeMax);
        for (var i = 0; i < touristNum; i++) {
          var who = tourists[i];
          who.x = tourLines[i][time].x;
          who.y = tourLines[i][time].y;
          who.visual.attr("cx", who.x).attr("cy", who.y);
          graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
        }
      }

      function ESlide() {
        d3.select(this).style("fill", "#888888");
        d3.select(this).classed("active", false);
      }

      //////////---------- Instantiate Classes ----------//////////
//Data holder, and loader update
      class Tourist {
        constructor (visual) {
          this.number = touristNum;
          this.visual = visual;
          this.knows = false;
          this.stamps = [];
          this.loadTime = 0;
          //this.allowance = 0;
          this.on = 0;
          this.a = 0;
          this.x = center[0];
          this.y = center[1];
        }
      }

      //////////----------Instantiate Functions----------//////////
      function GoToPoint(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var dLoc = [value[0] - who.x, value[1] - who.y];
        var dist = Math.sqrt(Math.pow(dLoc[1], 2) + Math.pow(dLoc[0], 2));
        if (dist < unit2Px / fps) {
          who.x = value[0];
          who.y = value[1];
        } else {
          var ang = Math.atan2(dLoc[1], dLoc[0]);
          who.x = who.x + (unit2Px / fps) * Math.cos(ang);
          who.y = who.y + (unit2Px / fps) * Math.sin(ang);
        }
      }

//Requirements: At center	Params:	Angle(time)	Description: Goes to wall
      function GoOutAtAngle(who, value) {
        if (who.on >= who.stamps.length) {
          who.a = value[0] * (Math.PI / 180);
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        if ((who.x == center[0] + unit2Px * Math.cos(who.a)) && (who.y == center[1] - unit2Px * Math.sin(who.a))) {
          who.on++;
          fxs[instruBinder[who.number][who.on][0]](who, instruBinder[who.number][who.on][1]);
        } else {
          GoToPoint(who, [center[0] + unit2Px * Math.cos(who.a), center[1] - unit2Px * Math.sin(who.a)]);
        }
      }

//Requirements: None	Params: null	Description: Wait indefinitely
      function Wait(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
      }

//Requirements: At wall		Params: direction	Description: Follows wall at direction indefinitely
      function FollowWall(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        who.a += (1 / fps) * dir;
        GoToPoint(who, [center[0] + unit2Px * Math.cos(who.a), center[1] - unit2Px * Math.sin(who.a)]);
      }

//Requirements: None	Params: time	Description: Wait for x time
      function WaitFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime = time + value[0] * fps;
        }
        if (time > who.loadTime) {
          who.on++;
          fxs[instruBinder[who.number][who.on][0]](who, instruBinder[who.number][who.on][1]);
        }
      }

//Requirements: At wall		Params: direction and angle(time)	Description: Follows wall at direction for x time
      function FollowWallFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime = time + value[1] * (Math.PI / 180) * fps;
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        if (time < who.loadTime) {
          who.a += (1 / fps) * dir;
          GoToPoint(who, [center[0] + unit2Px * Math.cos(who.a), center[1] - unit2Px * Math.sin(who.a)]);
        } else {
          who.on++;
          fxs[instruBinder[who.number][who.on][0]](who, instruBinder[who.number][who.on][1]);
        }
      }

//Requirements: At wall		Params: null	Description: Goes to center
      function GoToCenter(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        if ((who.x == center[0]) && (who.y == center[1])) {
          who.on++;
          fxs[instruBinder[who.number][who.on][0]](who, instruBinder[who.number][who.on][1]);
        } else {
          GoToPoint(who, center);
        }
      }

//Requirements: None	Params: null	Description: Goes to center of all bots
      function WaitAverage(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var sumPosition = [0, 0];
        var totalNum = 0;
        for (i = 0; i < tourists.length; i++) {
          if (tourists[i].on != 6) {
            totalNum++;
            sumPosition[0] += tourists[i].x;
            sumPosition[1] += tourists[i].y;
          }
        }
        sumPosition[0] /= totalNum;
        sumPosition[1] /= totalNum;
        GoToPoint(who, sumPosition);
      }






      function Start() {
        //Background Visuals
        fieldSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black")
                     .on("mousemove", ChoosExit).on("click", exitChosen);
        graphSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black");
        fieldSVG.append("text").attr("x",  center[0]).attr("y", unit2Px * (1 / 5))
                .style("text-anchor", "middle").style("font-size", unit2Px * (1 / 5)).text("Search and Exit");
        fieldSVG.append("text").attr("x",  center[0]).attr("y", unit2Px * (3 / 10))
                .style("text-anchor", "middle").style("font-size", unit2Px * (1 / 10)).text("Circle Wireless");
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px)
                .style("fill-opacity", 0.0).style("stroke", "#000000");
        //Tourist Visuals
        for (var i = 0; i < instruBinder.length; i++) {
          tourColors.push(RandomColor());
          tourists.push(new Tourist(fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1])
                                    .attr("r", unit2Px / 16)
                                    .style("fill", tourColors[i]), instruBinder[i]));
          touristNum++;
          tourLines.push([]);
          graphDots.push(graphSVG.append("circle").attr("cx", unit2Px * (10 / 25))
                         .attr("cy", unit2Px * 4 * (20 / 25) - unit2Px * (10 / 25)).attr("r", unit2Px / 16)
                         .style("fill", tourColors[i]));
          graphLines.push([]);
        }
        //Unit Circle Visuals
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", 2).style("fill", "#000000");
        fieldSVG.append("circle").attr("class", "exit").attr("cx", fieldExit[0]).attr("cy", fieldExit[1]).attr("r", 2)
                .style("fill", "#000000");
        fieldSVG.append("line").attr("x1", 2 * unit2Px).attr("y1", unit2Px).attr("x2",  2 * unit2Px).attr("y2", 3 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("line").attr("x1", unit2Px).attr("y1", 2 * unit2Px).attr("x2",  3 * unit2Px).attr("y2", 2 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("text").attr("x", 3.1 * unit2Px).attr("y", center[1])
                .style("text-anchor", "left").style("font-size", unit2Px / 5).text("0");
        fieldSVG.append("text").attr("x", center[0]).attr("y", .9 * unit2Px)
                .style("text-anchor", "middle").style("font-size", unit2Px / 5).text("90");
        //Time Slider and Buttons
        timeText = graphSVG.append("text").attr("x", unit2Px * 1.1).attr("y", unit2Px * .4)
                   .style("font-size", unit2Px * (8 / 25)).style("text-anchor", "right").text("0");
        frameText = graphSVG.append("text").attr("x", unit2Px * 1.1).attr("y", unit2Px * .7)
                    .style("font-size", unit2Px * (8 / 25)).style("text-anchor", "right").text("0");
        timeBox = graphSVG.append("rect").attr("width", 4 * unit2Px).attr("height", unit2Px / 8)
                          .attr("fill-opacity", 0.0).style("stroke", "#000000");
        timeSlide = graphSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                    .attr("class", "reveal").style("fill", "#888888")
                    .call(d3.drag().on("start", SSlide).on("drag", MSlide).on("end", ESlide));
        graphSVG.append("rect").attr("x", unit2Px * (19 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4)
                .attr("class", "reveal").attr("height", unit2Px / 4).style("fill", "#00ff00")
                .on("click", () => {timeDirect = 1;});
        graphSVG.append("rect").attr("x", unit2Px * (10 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                .attr("class", "reveal").style("fill", "#0000ff").on("click", () => {timeDirect = 0;});
        graphSVG.append("rect").attr("x", unit2Px * (1 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                .attr("class", "reveal").style("fill", "#ff0000")
                .on("click", () => {timeDirect = -1;});
        //Tourist Info Visual
        graphSVG.append("path").attr("d", 'M' + unit2Px * (1 / 25) + ',' + unit2Px * (16 / 25) + 'L' + unit2Px * (6 / 25) + ',' + unit2Px * (11 / 25)
                                                + 'L' + unit2Px * (6 / 25) + ',' + unit2Px * (21 / 25) + 'L' + unit2Px * (1 / 25) + ',' + unit2Px * (16 / 25))
                     .attr("class", "select").on("click", () => {UpdateInfo(-1);});
        selectText = graphSVG.append("text").attr("x", unit2Px * (13 / 25)).attr("y", unit2Px * (18 / 25)).attr("text-anchor", "middle")
                     .attr("class", "select").style("font-size", unit2Px * (7 / 25)).text("0");
        graphSVG.append("path").attr("d", 'M' + unit2Px * (25 / 25) + ',' + unit2Px * (16 / 25) + 'L' + unit2Px * (20 / 25) + ',' + unit2Px * (11 / 25)
                                                   + 'L' + unit2Px * (20 / 25) + ',' + unit2Px * (21 / 25) + 'L' + unit2Px * (25 / 25) + ',' + unit2Px * (16 / 25))
                   .attr("class", "select").on("click", () => {UpdateInfo(1);});
        graphSVG.append("path").attr("d", 'M' + unit2Px * (10 / 25) + ',' + unit2Px * (50 / 25)
                                        + 'L' + unit2Px * (10 / 25) + ',' + unit2Px * (90 / 25)
                                        + 'L' + unit2Px * (90 / 25) + ',' + unit2Px * (90 / 25))
                .style("fill", "none").style("stroke", "#000000");
        graphSVG.append("text").attr("x", unit2Px * (5 / 25)).attr("y", unit2Px * (70 / 25)).attr("text-anchor", "middle")
                .attr("transform", "rotate(-90," + unit2Px * (5 / 25) + ',' + unit2Px * (70 / 25) + ')')
                .style("font-size", unit2Px * (5 / 25)).style("fill", "#000000").text("Distance from Exit");
        graphSVG.append("text").attr("x", unit2Px * 2).attr("y", unit2Px * (395 / 100)).attr("text-anchor", "middle")
                .style("font-size", unit2Px * (5 / 25)).style("fill", "#000000").text("Time");
      }

//Create a random hexadecimal color
      function RandomColor() {
        var RGB = [];
        RGB[0] = Math.floor(Math.random() * 256).toString(16);
        RGB[1] = Math.floor(Math.random() * 256).toString(16);
        RGB[2] = Math.floor(Math.random() * 256).toString(16);
        for (j = 0; j < 3; j++) {if (RGB[j].length == 1) {RGB[j] = '0' + RGB[j];}}
        return('#' + RGB[0] + RGB[1] + RGB[2]);
      }

//Controls exit positioning for user's choice
      function ChoosExit() {
        exitAngle = Math.atan2(d3.event.x - center[0], d3.event.y - center[1]) - (Math.PI / 2);
        fieldExit = [center[0] + unit2Px * Math.cos(exitAngle), center[1] - unit2Px * Math.sin(exitAngle)];
        d3.select(".exit").attr("cx", fieldExit[0]).attr("cy", fieldExit[1]);
      }

//Turns off exit choosing events, and starts loading
      function exitChosen() {
        fieldSVG.on("mousemove", null).on("click", null);
        projector = setInterval(LoadAnim, 1000 / fps);
      }

//Control times, and update bots
      function LoadAnim() {
        if (time > timeMax) {
          UpdateInfo(0);
          clearInterval(projector);
          projector = setInterval(PlayAnim, 1000 / fps);
        } else {
          for (var i = 0; i < tourists.length; i++) {
            var who = tourists[i];
            fxs[instruBinder[i][who.on][0]](who, instruBinder[i][who.on][1]);
            who.visual.attr("cx", who.x).attr("cy", who.y);
            LoadLines(i);
          }
          time++;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
          timeBox.attr("width", (time / timeMax) * 4 * unit2Px);
        }
        timeText.text("Time: " + Math.floor((10000 * time) / fps) / 10000);
        frameText.text("Frame: " + time);
      }

//Create lines, and update graph dot positions, as well recreating image of path.
      function LoadLines(i) {
        var dista = unit2Px * 4 - (Math.sqrt(Math.pow(fieldExit[0] - tourists[i].x, 2) + Math.pow(fieldExit[1] - tourists[i].y, 2)) * (20 / 25));
        graphDots[i].attr("cx", (unit2Px * (10 / 25) + (time / timeMax) * (80 / 25) * unit2Px)).attr("cy", (dista - unit2Px * (10 / 25)));
        if (time > 0) {
          tourLines[i].push({x:tourists[i].x, y:tourists[i].y});
          tourLine[i].remove();
          tourLine[i] = fieldSVG.append("path").attr("d", lineFx(tourLines[i]))
                        .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none");
          graphLines[i].push({x:(unit2Px * (10 / 25) + (time / timeMax) * (80 / 25) * unit2Px), y:(dista - unit2Px * (10 / 25))});
          graphLine[i].remove();
          graphLine[i] = graphSVG.append("path").attr("d", lineFx(graphLines[i]))
                         .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none");
        } else {
          tourLines[i].push({x:center[0], y:center[1]});
          tourLine.push(fieldSVG.append("path").attr("d", lineFx(tourLines[i]))
                        .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none"));
          graphLines[i].push({x:(unit2Px * (10 / 25) + (time / timeMax) * (80 / 25) * unit2Px), y:(dista - unit2Px * (10 / 25))});
          graphLine.push(graphSVG.append("path").attr("d", lineFx(graphLines[i]))
                         .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none"));
        }
      }

      function PlayAnim() {
        if (time < 0) {
          time = 0;
          timeDirect = 0;
        } else if (time > timeMax) {
          time = timeMax;
          timeDirect = 0;
        }
        if (timeDirect != 0) {
          for (var i = 0; i < touristNum; i++) {
            var who = tourists[i];
            who.x = tourLines[i][time].x;
            who.y = tourLines[i][time].y;
            who.visual.attr("cx", who.x).attr("cy", who.y);
            graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
          }
          time += timeDirect;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
        }
        timeText.text("Time: " + Math.floor((10000 * time) / fps) / 10000);
        frameText.text("Frame: " + time);
      }

      function UpdateInfo(delta) {
        if (selectText.text() != 0) {
          tourists[selectText.text() - 1].visual.attr("r", unit2Px / 16);
          graphDots[selectText.text() - 1].attr("r", unit2Px / 16);
          tourLine[selectText.text() - 1].style("stroke-opacity", 0.5);
          graphLine[selectText.text() - 1].style("stroke-opacity", 0.5);
        }
        delta += +selectText.text();
        if (delta < 0) {delta = tourists.length;}
        else if (delta > tourists.length) {delta = 0;}
        selectText.text(delta);
        if (delta != 0) {
          tourists[delta - 1].visual.attr("r", unit2Px / 8);
          graphDots[delta - 1].attr("r", unit2Px / 8);
          tourLine[delta - 1].style("stroke-opacity", 1).raise();
          graphLine[delta - 1].style("stroke-opacity", 1).raise();
          d3.selectAll(".select").style("fill", tourColors[delta - 1]);
        }
      }

      //////////----------Initial Function Call----------//////////
      Start();

    </script>
  </body>
</html>
