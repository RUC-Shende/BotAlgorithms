<!doctype html>

<html>
  <head>
    <!--<script src = "https://d3js.org/d3.v5.min.js"></script>-->
    <script src = "d3.min.js"></script>
  </head>
  <body>
    <h1>Evacuate Room</h1>
    <p>Circle Room</p>
    <script>
      //Learning Jupiter NoteBook
      //////////----------Instantiate Variables----------//////////
      var loading = true;
      var fxs = [GoOutAtAngle, Wait, FollowWall, WaitFor, FollowWallFor, GoToCenter, WaitAverage];

      var time = 0;
      var timeMax = 10000;//in milliseconds
      var timeBox;
      var timeSlide;

      var projector;
      var fieldSVG;
      var unit2Px = 0;
      var center = [0, 0];
      var fps = 120;
      var touristNum = 0;
      var tourists = [];

      var fieldExit = 0;
      var wireless = true;
      var instruBinder = [
                          [[0, [45]], [2, ['left']]],
                          [[0, [-125]], [1, [null]]],
                          [[0, [170]], [3, [1]], [2, ['right']]],
                          [[0, [87]], [4, ['left', 60]], [1, [null]]],
                          [[0, [30]], [4, ['right', 60]], [5, [null]], [1, [null]]],
                          [[6, [null]]]
                         ];

      //////////--------Instantiate Call Functions--------//////////
      //The box's dragging ability
      function SSlide() {
        d3.select(this).style("fill", "orange");
        d3.select(this).classed("active", true);
      }
      function MSlide() {
        var mousePos = d3.event.x;
        if (mousePos < 0) {
          mousePos = 0;
        } else if (mousePos > (31 / 8) * unit2Px) {
          mousePos = (31 / 8) * unit2Px;
        }
        d3.select(this).attr("x", mousePos);
        time = (mousePos / ((31 / 8) * unit2Px)) * timeMax;
        tourists.forEach((tourist) => {
          tourist.Update();
        });
      }
      function ESlide() {
        d3.select(this).style("fill", "#888888");
        d3.select(this).classed("active", false);
      }

      //////////---------- Instantiate Classes ----------//////////
      //A basic class, only holds data, and calls updates.
      class Tourist {
        constructor (visual, instructions) {
          this.number = touristNum;
          touristNum++;
          this.visual = visual;
          this.instru = instructions;
          this.stamps = [];
          this.on = 0;
          this.a = 0;
          this.x = center[0];
          this.y = center[1];
        }
        //A loading update for genrating the data before hand
        LoadUpdate() {
          fxs[this.instru[this.on][0]](this, this.instru[this.on][1]);
        }
        //A standard update, initialized from the load update
        Update() {
          for (i = 0; i < this.stamps.length; i++) {
            if (this.stamps[i][0] <= time) {
              this.on = i;
            } else {
              break;
            }
          }
          fxs[this.stamps[this.on][1]](this, this.stamps[this.on][2]);
        }
      }

      //////////----------Instantiate Functions----------//////////

//	Start/Middle; Requires at center and angle; Bot goes to wall
      function GoOutAtAngle(who, value) {
        if (who.on >= who.stamps.length) {
          who.a = value[0] * (Math.PI / 180);
          who.stamps.push([time, 0, value, who.a, who.x, who.y]);
        }
        var timePerc = (time - who.stamps[who.on][0]) / 1000;
        if (timePerc <= 1) {
          who.x = center[0] + unit2Px * Math.cos(who.a) * timePerc;
          who.y = center[1] - unit2Px * Math.sin(who.a) * timePerc;
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.on++;
        }
      }

//	End; Requires nothing; Bot stops where it is.
      function Wait(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 1, value, who.a, who.x, who.y]);
        }
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//	End; Requires direction; Robot follows wall
      function FollowWall(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 2, value, who.a, who.x, who.y]);
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        who.a = who.stamps[who.on][3] + ((time - who.stamps[who.on][0]) / 1000) * dir;
        who.x = center[0] + unit2Px * Math.cos(who.a);
        who.y = center[1] - unit2Px * Math.sin(who.a);
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//	Start/Middle; Requires time; Wait for time
      function WaitFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 3, value, who.a, who.x, who.y]);
        }
        if (time < (who.stamps[who.on][0] + value[0] * 1000)) {
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.on++;
        }
      }

//	Middle; Requires direction and angle(time); bot travels along wall for angle(time)
      function FollowWallFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 4, value, who.a, who.x, who.y]);
        }
        if (time < (who.stamps[who.on][0] + value[1] * (Math.PI / 180) * 1000)) {
          var dir = (value[0] == 'left') ? (1) : (-1);
          who.a = who.stamps[who.on][3] + ((time - who.stamps[who.on][0]) / 1000) * dir;
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] - unit2Px * Math.sin(who.a);
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.on++;
        }
      }

//	Middle; Requires not at center; Bot goes to center
      function GoToCenter(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 5, value, who.a, who.x, who.y]);
        }
        var timePerc = (time - who.stamps[who.on][0]) / 1000;
        console.log(timePerc);
        if (timePerc <= 1) {
          who.x = who.stamps[who.on][4] - unit2Px * Math.cos(who.a) * timePerc;
          who.y = who.stamps[who.on][5] + unit2Px * Math.sin(who.a) * timePerc;
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.on++;
        }
      }

//	Start/Middle; Required nothing; Bot stays at point between other bots not in average
      function WaitAverage(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([time, 6, value, who.a, who.x, who.y]);
        }
        var sumPosition = [0, 0];
        var totalNum = 0;
        for (i = 0; i < tourists.length; i++) {
          if (tourists[i].on != 6) {
            totalNum++;
            sumPosition[0] += tourists[i].x;
            sumPosition[1] += tourists[i].y;
          }
        }
        sumPosition[0] /= totalNum;
        sumPosition[1] /= totalNum;
        who.x = sumPosition[0];
        who.y = sumPosition[1];
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }





//Initialize the screen
      function Start() {
        unit2Px = (window.innerHeight <= window.innerWidth) ? (window.innerHeight / 5) : (window.innerWidth / 5);
        center = [unit2Px * 2, unit2Px * 2];
        fieldSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4).style("border", "1px solid black");
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px).style("fill-opacity", 0.0).style("stroke", "#000000");
        for (i = 0; i < instruBinder.length; i++) {
          tourists.push(new Tourist(fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1])
                                            .attr("r", unit2Px / 16).style("fill", RandomColor()), instruBinder[i]));
        }
        fieldExit = [center[0] + unit2Px * Math.cos(fieldExit * (Math.PI / 180)), center[1] + unit2Px * Math.sin(fieldExit * (Math.PI / 180))];
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", 1).style("fill", "#000000");
        timeBox = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8).style("fill-opacity", 0.0).style("stroke", "#000000");
        timeSlide = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                    .attr("visibility", "hidden").style("fill", "#888888")
                    .call(d3.drag().on("start", SSlide).on("drag", MSlide).on("end", ESlide));
        projector = setInterval(LoadAnim, 1000 / fps);
      }

//Create a random color, makes robots distinct.
      function RandomColor() {
        var colorRed = Math.floor(Math.random() * 256).toString(16);
        var colorGreen = Math.floor(Math.random() * 256).toString(16);
        var colorBlue = Math.floor(Math.random() * 256).toString(16);
        return(colorRed + colorGreen + colorBlue);
      }

//Load interval
      function LoadAnim() {
        if (time >= timeMax) {
          timeSlide.attr("visibility", "visible");
          clearInterval(projector);
        } else {
          tourists.forEach((tourist) => {
            tourist.LoadUpdate();
          });
          time += (1000 / fps);
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
          timeBox.attr("width", (time / timeMax) * 4 * unit2Px);
        }
      }

      //////////----------Initial Function Call----------//////////
      Start();

    </script>
  </body>
</html>
