<!doctype html>

<html>
  <head>
    <!--<script src = "https://d3js.org/d3.v5.min.js"></script>-->
    <script src = "d3.min.js"></script>
  </head>
  <body>
    <h1>Evacuate Room</h1>
    <p>Circle Room - Wireless</p>
    <script>
      //////////----------Instantiate Variables----------//////////
      var fxs = [GoOutAtAngle, Wait, FollowWall, WaitFor, FollowWallFor, GoToCenter, WaitAverage, GoToExit];

      var time = 0;
      var fps = 60;
      var timeMax = 10 * fps;

      var timeBox;
      var timeSlide;
      var timeDirect;

      var selectText;

      var projector;
      var fieldSVG;
      var unit2Px = ((window.innerHeight <= window.innerWidth) ?
                    (window.innerHeight) : (window.innerWidth)) / 5;
      var center = [unit2Px * 2, unit2Px * 2];
      var touristNum = 0;

      var tourColors = [];
      var tourists = [];

      var graphSVG;
      var graphDots = [];

      var lineFx = d3.line().x((d) => {return(d.x);}).y((d) => {return(d.y);});
      var tourLines = [];
      var tourLine = [];
      var graphLines = [];
      var graphLine = [];

      var exitAngle = 180;
      var fieldExit = [center[0] + unit2Px * Math.cos(exitAngle * (Math.PI / 180)),
                       center[1] + unit2Px * Math.sin(exitAngle * (Math.PI / 180))];
      var wireless = true;
      var sendSignal = 0;
      var instruBinder = [
                          [[0, [30]], [2, ['left']]],
                          [[0, [-30]], [2, ['right']]],
                          [[0, [30]], [4, ['right', 60]], [5, [null]], [1, [null]]]
                         ];

      //////////--------Instantiate Call Functions--------//////////
//Drag function, updates tourists and graph dots relative to lines
      function SSlide() {
        d3.select(this).style("fill", "orange");
        d3.select(this).classed("active", true);
      }

      function MSlide() {
        var mousePos = d3.event.x;
        if (mousePos < 0) {
          mousePos = 0;
        } else if (mousePos > (31 / 8) * unit2Px) {
          mousePos = (31 / 8) * unit2Px;
        }
        d3.select(this).attr("x", mousePos);
        time = Math.round((mousePos / ((31 / 8) * unit2Px)) * timeMax);
        for (var i = 0; i < touristNum; i++) {
          var who = tourists[i];
          who.x = tourLines[i][time].x;
          who.y = tourLines[i][time].y;
          who.visual.attr("cx", who.x).attr("cy", who.y);
          graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
        }
      }

      function ESlide() {
        d3.select(this).style("fill", "#888888");
        d3.select(this).classed("active", false);
      }

      //////////---------- Instantiate Classes ----------//////////
//Data holder, and loader update
      class Tourist {
        constructor (visual, instructions) {
          this.number = touristNum;
          touristNum++;
          this.visual = visual;
          this.knows = false;
          this.instru = instructions;
          this.stamps = [];
          this.loadTime = 0;
          this.on = 0;
          this.a = 0;
          this.x = center[0];
          this.y = center[1];
        }
        LoadUpdate() {
          if (this.knows) {
            fxs[7](this, [null])
          } else {
            fxs[this.instru[this.on][0]](this, this.instru[this.on][1]);
            if (Math.sqrt(Math.pow(fieldExit[1] - this.y ,2) + Math.pow(fieldExit[0] - this.x ,2)) < (unit2Px / fps)) {
              if (sendSignal < 1) {
                sendSignal++;
              }
            }
          }
          this.visual.attr("cx", this.x).attr("cy", this.y);
        }
      }

      //////////----------Instantiate Functions----------//////////
      function GoToExit(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var dLoc = [fieldExit[0] - who.x, fieldExit[1] - who.y];
        var dist = Math.sqrt(Math.pow(dLoc[1], 2) + Math.pow(dLoc[0], 2));
        if (dist < unit2Px / fps) {
          who.x = fieldExit[0];
          who.y = fieldExit[1];
        } else {
          var ang = Math.atan2(dLoc[1], dLoc[0]);
          who.x = who.x + (unit2Px / fps) * Math.cos(ang);
          who.y = who.y + (unit2Px / fps) * Math.sin(ang);
        }
      }

//Requirements: At center	Params:	Angle(time)	Description: Goes to wall
      function GoOutAtAngle(who, value) {
        if (who.on >= who.stamps.length) {
          who.a = value[0] * (Math.PI / 180);
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime += fps;
        }
        if (time <= who.loadTime) {
          var timePerc = (time - who.stamps[who.on][0]) / fps;
          who.x = center[0] + unit2Px * Math.cos(who.a) * timePerc;
          who.y = center[1] - unit2Px * Math.sin(who.a) * timePerc;
        } else {
          who.on++;
          fxs[who.instru[who.on][0]](who, who.instru[who.on][1]);
        }
      }

//Requirements: None	Params: null	Description: Wait indefinitely
      function Wait(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
      }

//Requirements: At wall		Params: null	Description: Follows wall at direction indefinitely
      function FollowWall(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        who.a = who.stamps[who.on][1] + ((time - who.stamps[who.on][0]) / fps) * dir;
        who.x = center[0] + unit2Px * Math.cos(who.a);
        who.y = center[1] - unit2Px * Math.sin(who.a);
      }

//Requirements: None	Params: time	Description: Wait for x time
      function WaitFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime += Math.round(value[0] * fps);
        }
        if (time > who.loadTime) {
          who.on++;
          fxs[who.instru[who.on][0]](who, who.instru[who.on][1]);
        }
      }

//Requirements: At wall		Params: direction and angle(time)	Description: Follows wall at direction for x time
      function FollowWallFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime += Math.round(value[1] * (Math.PI / 180) * fps);
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        if (time <= who.loadTime) {
          who.a = who.stamps[who.on][1] + ((time - who.stamps[who.on][0]) / fps) * dir;
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] - unit2Px * Math.sin(who.a);
        } else {
          who.on++;
          fxs[who.instru[who.on][0]](who, who.instru[who.on][1]);
        }
      }

//Requirements: At wall		Params: null	Description: Goes to center
      function GoToCenter(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
          who.loadTime += fps;
        }
        if (time <= who.loadTime) {
          var timePerc = (who.loadTime - time) / fps;
          who.x = center[0] + unit2Px * Math.cos(who.a) * timePerc;
          who.y = center[1] - unit2Px * Math.sin(who.a) * timePerc;
        } else {
          who.on++;
          fxs[who.instru[who.on][0]](who, who.instru[who.on][1]);
        }
      }

//Requirements: None	Params: null	Description: Goes to center of all bots
      function WaitAverage(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, who.a, who.x, who.y]);
        }
        var sumPosition = [0, 0];
        var totalNum = 0;
        for (i = 0; i < tourists.length; i++) {
          if (tourists[i].on != 6) {
            totalNum++;
            sumPosition[0] += tourists[i].x;
            sumPosition[1] += tourists[i].y;
          }
        }
        sumPosition[0] /= totalNum;
        sumPosition[1] /= totalNum;
        var dLoc = [sumPosition[0] - who.x, sumPosition[1] - who.y];
        var dist = Math.sqrt(Math.pow(dLoc[1], 2) + Math.pow(dLoc[0], 2));
        if (dist < unit2Px / fps) {
          who.x = sumPosition[0];
          who.y = sumPosition[1];
        } else {
          var ang = Math.atan2(dLoc[1], dLoc[0]);
          who.x = who.x + (unit2Px / fps) * Math.cos(ang);
          who.y = who.y + (unit2Px / fps) * Math.sin(ang);
        }
      }





      function Start() {
//Background Visuals
        fieldSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black");
        graphSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black");
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px)
                .style("fill-opacity", 0.0).style("stroke", "#000000");
//Tourist Visuals
        for (var i = 0; i < instruBinder.length; i++) {
          tourColors.push(RandomColor());
          tourists.push(new Tourist(fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1])
                                    .attr("r", unit2Px / 16)
                                    .style("fill", tourColors[i]), instruBinder[i]));
          tourLines.push([]);
          graphDots.push(graphSVG.append("circle").attr("cy", unit2Px * 4).attr("r", unit2Px / 16)
                         .style("fill", tourColors[i]));
          graphLines.push([]);
        }

//Unit Circle Visuals
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", 2).style("fill", "#000000");
        fieldSVG.append("circle").attr("cx", fieldExit[0]).attr("cy", fieldExit[1]).attr("r", 2).style("fill", "#000000");
        fieldSVG.append("line").attr("x1", 2 * unit2Px).attr("y1", unit2Px).attr("x2",  2 * unit2Px).attr("y2", 3 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("line").attr("x1", unit2Px).attr("y1", 2 * unit2Px).attr("x2",  3 * unit2Px).attr("y2", 2 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("text").attr("x", 3.1 * unit2Px).attr("y", center[1])
                .style("text-anchor", "left").style("font-size", unit2Px / 5).text("0");
        fieldSVG.append("text").attr("x", center[0]).attr("y", .9 * unit2Px)
                .style("text-anchor", "middle").style("font-size", unit2Px / 5).text("90");

//Time Slider and Buttons
        timeBox = graphSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                          .attr("fill-opacity", 0.0).style("stroke", "#000000");
        timeSlide = graphSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                    .attr("class", "reveal").attr("visibility", "hidden").style("fill", "#888888")
                    .call(d3.drag().on("start", SSlide).on("drag", MSlide).on("end", ESlide));
        graphSVG.append("rect").attr("x", unit2Px * (19 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4)
                .attr("class", "reveal").attr("height", unit2Px / 4).attr("visibility", "hidden").style("fill", "#00ff00")
                .on("click", () => {timeDirect = 1;});
        graphSVG.append("rect").attr("x", unit2Px * (10 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                .attr("class", "reveal").attr("visibility", "hidden").style("fill", "#0000ff").on("click", () => {timeDirect = 0;});
        graphSVG.append("rect").attr("x", unit2Px * (1 / 25)).attr("y", unit2Px * (4 / 25)).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                .attr("class", "reveal").attr("visibility", "hidden").style("fill", "#ff0000")
                .on("click", () => {timeDirect = -1;});
        projector = setInterval(LoadAnim, 1000 / fps);

//Tourist Info Visual
        graphSVG.append("path").attr("d", 'M' + unit2Px * (1 / 25) + ',' + unit2Px * (16 / 25) + 'L' + unit2Px * (6 / 25) + ',' + unit2Px * (11 / 25)
                                                + 'L' + unit2Px * (6 / 25) + ',' + unit2Px * (21 / 25) + 'L' + unit2Px * (1 / 25) + ',' + unit2Px * (16 / 25))
                     .attr("class", "reveal select").attr("visibility", "hidden").on("click", () => {UpdateInfo(-1);});
        selectText = graphSVG.append("text").attr("x", unit2Px * (13 / 25)).attr("y", unit2Px * (18 / 25)).attr("text-anchor", "middle")
                     .attr("class", "reveal select").attr("visibility", "hidden").style("font-size", unit2Px * (7 / 25)).text("1");
        graphSVG.append("path").attr("d", 'M' + unit2Px * (25 / 25) + ',' + unit2Px * (16 / 25) + 'L' + unit2Px * (20 / 25) + ',' + unit2Px * (11 / 25)
                                                   + 'L' + unit2Px * (20 / 25) + ',' + unit2Px * (21 / 25) + 'L' + unit2Px * (25 / 25) + ',' + unit2Px * (16 / 25))
                   .attr("class", "reveal select").attr("visibility", "hidden").on("click", () => {UpdateInfo(1);});
        graphSVG.append("path").attr("d", 'M' + unit2Px * (10 / 25) + ',' + unit2Px * (50 / 25)
                                        + 'L' + unit2Px * (10 / 25) + ',' + unit2Px * (90 / 25)
                                        + 'L' + unit2Px * (90 / 25) + ',' + unit2Px * (90 / 25))
                .style("fill", "none").style("stroke", "#000000");
        graphSVG.append("text").attr("x", unit2Px * (5 / 25)).attr("y", unit2Px * (70 / 25)).attr("text-anchor", "middle")
                .attr("transform", "rotate(-90," + unit2Px * (5 / 25) + ',' + unit2Px * (70 / 25) + ')')
                .style("font-size", unit2Px * (5 / 25)).style("fill", "#000000").text("Distance from Exit");
        graphSVG.append("text").attr("x", unit2Px * 2).attr("y", unit2Px * (395 / 100)).attr("text-anchor", "middle")
                .style("font-size", unit2Px * (5 / 25)).style("fill", "#000000").text("Time");
      }

//Create a random hexadecimal color
      function RandomColor() {
        var RGB = [];
        RGB[0] = Math.floor(Math.random() * 256).toString(16);
        RGB[1] = Math.floor(Math.random() * 256).toString(16);
        RGB[2] = Math.floor(Math.random() * 256).toString(16);
        for (var j = 0; j < 3; j++) {if (RGB[j].length == 1) {RGB[j] = '0' + RGB[j];}}
        return('#' + RGB[0] + RGB[1] + RGB[2]);
      }

//Control times, and update bots
      function LoadAnim() {
        if (time > timeMax) {
          d3.selectAll(".reveal").attr("visibility", "visible");
          UpdateInfo(0);
          clearInterval(projector);
          setInterval(PlayAnim, 1000 / fps);
        } else {
          tourists.forEach((tourist) => {
            tourist.LoadUpdate();
          });
          if (sendSignal == 1) {
            for (var i = 0; i < tourists.length; i++) {
              tourists[i].knows = true;
              tourists[i].on++;
            }
            sendSignal++;
          }
          for (var i = 0; i < tourists.length; i++) {
            LoadLines(i);
          }
          time++;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
          timeBox.attr("width", (time / timeMax) * 4 * unit2Px);
        }
      }

//Create lines, and update graph dot positions, as well recreating image of path.
      function LoadLines(i) {
        var dista = unit2Px * 4 - (Math.sqrt(Math.pow(fieldExit[0] - tourists[i].x, 2) + Math.pow(fieldExit[1] - tourists[i].y, 2)) * (20 / 25));
        graphDots[i].attr("cx", (unit2Px * (10 / 25) + (time / timeMax) * (80 / 25) * unit2Px)).attr("cy", (dista - unit2Px * (10 / 25)));
        if (time > 0) {
          tourLine[i].remove();
          graphLine[i].remove();
        }
        tourLines[i].push({x:tourists[i].x, y:tourists[i].y});
        tourLine[i] = fieldSVG.append("path").attr("d", lineFx(tourLines[i]))
                      .style("stroke", tourColors[i]).style("stroke-width", unit2Px * (1 / 25)).style("stroke-opacity", 0.5).style("fill", "none");
        graphLines[i].push({x:graphDots[i].attr("cx"), y:graphDots[i].attr("cy")});
        graphLine[i] = graphSVG.append("path").attr("d", lineFx(graphLines[i]))
                       .style("stroke", tourColors[i]).style("stroke-width", unit2Px * (1 / 25)).style("stroke-opacity", 0.5).style("fill", "none");
      }

      function PlayAnim() {
        if (time < 0) {
          time = 0;
          timeDirect = 0;
        } else if (time > timeMax) {
          time = timeMax;
          timeDirect = 0;
        }
        if (timeDirect != 0) {
          for (var i = 0; i < touristNum; i++) {
            var who = tourists[i];
            who.x = tourLines[i][time].x;
            who.y = tourLines[i][time].y;
            who.visual.attr("cx", who.x).attr("cy", who.y);
            graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
          }
          time += timeDirect;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
        }
      }

      function UpdateInfo(delta) {
        if (selectText.text() != 0) {
          tourists[selectText.text() - 1].visual.attr("r", unit2Px / 16);
          graphDots[selectText.text() - 1].attr("r", unit2Px / 16);
          tourLine[selectText.text() - 1].style("stroke-opacity", 0.5);
          graphLine[selectText.text() - 1].style("stroke-opacity", 0.5);
        }
        delta += +selectText.text();
        if (delta < 0) {delta = 0;}
        else if (delta > tourists.length) {delta = tourists.length;}
        selectText.text(delta);
        if (delta != 0) {
          tourists[delta - 1].visual.attr("r", unit2Px / 8);
          graphDots[delta - 1].attr("r", unit2Px / 8);
          tourLine[delta - 1].style("stroke-opacity", 1).raise();
          graphLine[delta - 1].style("stroke-opacity", 1).raise();
          d3.selectAll(".select").style("fill", tourColors[delta - 1]);
        }
      }

      //////////----------Initial Function Call----------//////////
      Start();

    </script>
  </body>
</html>
