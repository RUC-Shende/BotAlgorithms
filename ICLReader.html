<!doctype html>

<html>
  <head>
    <!--<script src = "https://d3js.org/d3.v5.min.js"></script>-->
    <script src = "d3.min.js"></script>
  </head>
  <body>
    <h1>Evacuate Room</h1>
    <p>Circle Room - Wireless</p>
    <script>
      //////////----------Instantiate Variables----------//////////
      var fxs = [GoOutAtAngle, Wait, FollowWall, WaitFor, FollowWallFor, GoToCenter, WaitAverage, GoToExit];

      var loading = true;
      var time = 0;
      var fps = 60;
      var timeMax = 10 * fps;

      var timeBox;
      var timeSlide;
      var timePlay;
      var timePause;
      var timeRewind;

      var projector;
      var fieldSVG;
      var unit2Px = (window.innerHeight <= window.innerWidth) ?
                    (window.innerHeight / 5) : (window.innerWidth / 5);
      var center = [unit2Px * 2, unit2Px * 2];
      var touristNum = 0;

      var tourColors = [];
      var tourists = [];

      var graphSVG;
      var graphDots = [];

      var lineFx = d3.line().x((d) => {return(d.x);}).y((d) => {return(d.y);});
      var tourLines = [];
      var tourLine = [];
      var graphLines = [];
      var graphLine = [];

      var exitAngle = 0;
      var fieldExit = [center[0] + unit2Px * Math.cos(exitAngle * (Math.PI / 180)),
                       center[1] + unit2Px * Math.sin(exitAngle * (Math.PI / 180))];
      var wireless = true;
      var sendSignal = 0;
      var instruBinder = [
                          [[0, [45]], [2, ['left']]],
                          [[0, [-125]], [1, [null]]],
                          [[0, [170]], [3, [1]], [2, ['right']]],
                          [[0, [87]], [4, ['left', 60]], [1, [null]]],
                          [[0, [30]], [4, ['right', 60]], [5, [null]], [1, [null]]],
                          [[0, [270]],[6, [null]]],
                          [[6, [null]]]
                         ];

      //////////--------Instantiate Call Functions--------//////////
//Drag function, updates tourists and graph dots relative to lines
      function SSlide() {
        d3.select(this).style("fill", "orange");
        d3.select(this).classed("active", true);
      }
      function MSlide() {
        var mousePos = d3.event.x;
        if (mousePos < 0) {
          mousePos = 0;
          timeRewind.attr("visibility", "hidden");
          timePlay.attr("visibility", "visible");
        } else if (mousePos > (31 / 8) * unit2Px) {
          mousePos = (31 / 8) * unit2Px;
          timePlay.attr("visibility", "hidden");
          timeRewind.attr("visibility", "visible");
        } else {
          timePlay.attr("visibility", "visible");
          timeRewind.attr("visibility", "visible");
        }
        d3.select(this).attr("x", mousePos);
        time = Math.round((mousePos / ((31 / 8) * unit2Px)) * timeMax);
        for (i = 0; i < touristNum; i++) {
          var who = tourists[i];
          who.x = tourLines[i][time].x;
          who.y = tourLines[i][time].y;
          who.visual.attr("cx", who.x).attr("cy", who.y);
          graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
        }
      }
      function ESlide() {
        d3.select(this).style("fill", "#888888");
        d3.select(this).classed("active", false);
      }

      //////////---------- Instantiate Classes ----------//////////
//Data holder, and loader update
      class Tourist {
        constructor (visual, instructions) {
          this.number = touristNum;
          touristNum++;
          this.visual = visual;
          this.knows = false;
          this.instru = instructions;
          this.stamps = [];
          this.loadTime = 0;
          this.on = 0;
          this.a = 0;
          this.x = center[0];
          this.y = center[1];
        }
        LoadUpdate() {
          if (this.knows) {
            fxs[7](this, [null])
          } else {
            fxs[this.instru[this.on][0]](this, this.instru[this.on][1]);
            if (Math.sqrt(Math.pow(fieldExit[1] - this.y ,2) + Math.pow(fieldExit[0] - this.x ,2)) < (unit2Px / fps)) {
              sendSignal++;
            }
          }
        }
      }

      //////////----------Instantiate Functions----------//////////
      function GoToExit(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 7, value, who.a, who.x, who.y]);
        }
        var dLoc = [fieldExit[0] - who.x, fieldExit[1] - who.y];
        var dist = Math.sqrt(Math.pow(dLoc[1], 2) + Math.pow(dLoc[0], 2));
        if (dist < unit2Px / fps) {
          who.x = fieldExit[0];
          who.y = fieldExit[1];
        } else {
          var ang = Math.atan2(dLoc[1], dLoc[0]);
          who.x = who.x + (unit2Px / fps) * Math.cos(ang);
          who.y = who.y + (unit2Px / fps) * Math.sin(ang);
        }
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//Requirements: At center	Params:	Angle(time)	Description: Goes to wall
      function GoOutAtAngle(who, value) {
        if (who.on >= who.stamps.length) {
          who.a = value[0] * (Math.PI / 180);
          who.stamps.push([who.loadTime, 0, value, who.a, who.x, who.y]);
          who.loadTime += fps;
        }
        if (time < who.loadTime) {
          var timePerc = (time - who.stamps[who.on][0]) / fps;
          who.x = center[0] + unit2Px * Math.cos(who.a) * timePerc;
          who.y = center[1] - unit2Px * Math.sin(who.a) * timePerc;
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] - unit2Px * Math.sin(who.a);
          who.visual.attr("cx", who.x).attr("cy", who.y);
          who.on++;
        }
      }

//Requirements: None	Params: null	Description: Wait indefinitely
      function Wait(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 1, value, who.a, who.x, who.y]);
        }
        who.visual.attr("cx", who.stamps[who.on][4]).attr("cy", who.stamps[who.on][5]);
      }

//Requirements: At wall		Params: null	Description: Follows wall at direction indefinitely
      function FollowWall(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 2, value, who.a, who.x, who.y]);
        }
        var dir = (value[0] == 'left') ? (1) : (-1);
        who.a = who.stamps[who.on][3] + ((time - who.stamps[who.on][0]) / fps) * dir;
        who.x = center[0] + unit2Px * Math.cos(who.a);
        who.y = center[1] - unit2Px * Math.sin(who.a);
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }

//Requirements: None	Params: time	Description: Wait for x time
      function WaitFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 3, value, who.a, who.x, who.y]);
          who.loadTime += value[0] * fps;
        }
        if (time < (who.stamps[who.on][0] + value[0] * fps)) {
          who.visual.attr("cx", who.stamps[who.on][4]).attr("cy", who.stamps[who.on][5]);
        } else {
          who.on++;
        }
      }

//Requirements: At wall		Params: direction and angle(time)	Description: Follows wall at direction for x time
      function FollowWallFor(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 4, value, who.a, who.x, who.y]);
          who.loadTime += value[1] * (Math.PI / 180) * fps;
        }
        if (time <= (who.stamps[who.on][0] + value[1] * (Math.PI / 180) * fps)) {
          var dir = (value[0] == 'left') ? (1) : (-1);
          who.a = who.stamps[who.on][3] + value[1] * (Math.PI / 180) * ((time - who.stamps[who.on][0]) / fps) * dir;
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] - unit2Px * Math.sin(who.a);
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          var dir = (value[0] == 'left') ? (1) : (-1);
          who.x = center[0] + unit2Px * Math.cos(who.a);
          who.y = center[1] - unit2Px * Math.sin(who.a);
          who.visual.attr("cx", who.x).attr("cy", who.y);
          who.on++;
        }
      }

//Requirements: At wall		Params: null	Description: Goes to center
      function GoToCenter(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 5, value, who.a, who.x, who.y]);
          who.loadTime += fps;
        }
        if (time < who.loadTime) {
          var timePerc = (time - who.stamps[who.on][0]) / fps;
          who.x = who.stamps[who.on][4] - unit2Px * Math.cos(who.stamps[who.on][3]) * timePerc;
          who.y = who.stamps[who.on][5] + unit2Px * Math.sin(who.stamps[who.on][3]) * timePerc;
          who.visual.attr("cx", who.x).attr("cy", who.y);
        } else {
          who.x = who.stamps[who.on][4] - unit2Px * Math.cos(who.stamps[who.on][3]);
          who.y = who.stamps[who.on][5] + unit2Px * Math.sin(who.stamps[who.on][3]);
          who.visual.attr("cx", who.x).attr("cy", who.y);
          who.on++;
        }
      }

//Requirements: None	Params: null	Description: Goes to center of all bots
      function WaitAverage(who, value) {
        if (who.on >= who.stamps.length) {
          who.stamps.push([who.loadTime, 6, value, who.a, who.x, who.y]);
        }
        var sumPosition = [0, 0];
        var totalNum = 0;
        for (i = 0; i < tourists.length; i++) {
          if (tourists[i].on != 6) {
            totalNum++;
            sumPosition[0] += tourists[i].x;
            sumPosition[1] += tourists[i].y;
          }
        }
        sumPosition[0] /= totalNum;
        sumPosition[1] /= totalNum;
        var dLoc = [sumPosition[0] - who.x, sumPosition[1] - who.y];
        var dist = Math.sqrt(Math.pow(dLoc[1], 2) + Math.pow(dLoc[0], 2));
        if (dist < unit2Px / fps) {
          who.x = sumPosition[0];
          who.y = sumPosition[1];
        } else {
          var ang = Math.atan2(dLoc[1], dLoc[0]);
          who.x = who.x + (unit2Px / fps) * Math.cos(ang);
          who.y = who.y + (unit2Px / fps) * Math.sin(ang);
        }
        who.visual.attr("cx", who.x).attr("cy", who.y);
      }





      function Start() {
//Visuals
        fieldSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black");
        graphSVG = d3.select("body").append("svg").attr("width", unit2Px * 4).attr("height", unit2Px * 4)
                     .style("float", "left").style("border", "1px solid black");
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", unit2Px)
                .style("fill-opacity", 0.0).style("stroke", "#000000");
        for (i = 0; i < instruBinder.length; i++) {
          tourColors.push(RandomColor());
          tourists.push(new Tourist(fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1])
                                    .attr("r", unit2Px / 16)
                                    .style("fill", tourColors[i]), instruBinder[i]));
          tourLines.push([]);
          graphDots.push(graphSVG.append("circle").attr("cy", unit2Px * 4).attr("r", unit2Px / 16)
                         .style("fill", tourColors[i]));
          graphLines.push([]);
        }
        fieldSVG.append("circle").attr("cx", center[0]).attr("cy", center[1]).attr("r", 2).style("fill", "#000000");
        fieldSVG.append("circle").attr("cx", fieldExit[0]).attr("cy", fieldExit[1]).attr("r", 2).style("fill", "#000000");
        fieldSVG.append("line").attr("x1", 2 * unit2Px).attr("y1", unit2Px).attr("x2",  2 * unit2Px).attr("y2", 3 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("line").attr("x1", unit2Px).attr("y1", 2 * unit2Px).attr("x2",  3 * unit2Px).attr("y2", 2 * unit2Px)
                .style("stroke", "#000000").style("stroke-width", .5);
        fieldSVG.append("text").attr("x", 3.1 * unit2Px).attr("y", center[1])
                .style("font-size", unit2Px / 5).text("0");
        fieldSVG.append("text").attr("x", center[0]).attr("y", .9 * unit2Px)
                .style("text-anchor", "middle").style("font-size", unit2Px / 5).text("90");

//Time Slider and Buttons
        timeBox = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                          .style("fill-opacity", 0.0).style("stroke", "#000000");
        timeSlide = fieldSVG.append("rect").attr("width", unit2Px / 8).attr("height", unit2Px / 8)
                    .attr("visibility", "hidden").style("fill", "#888888")
                    .call(d3.drag().on("start", SSlide).on("drag", MSlide).on("end", ESlide));
        timePlay = fieldSVG.append("rect").attr("x", unit2Px / 2).attr("y", unit2Px / 8).attr("width", unit2Px / 4)
                           .attr("height", unit2Px / 4).attr("visibility", "hidden").style("fill", "#00ff00")
                           .on("click", () => {projector = setInterval(PlayAnim, 1000 / fps);});
        timePause = fieldSVG.append("rect").attr("x", unit2Px / 4).attr("y", unit2Px / 8).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                            .attr("visibility", "hidden").style("fill", "#0000ff").on("click", PauseAnim);
        timeRewind = fieldSVG.append("rect").attr("y", unit2Px / 8).attr("width", unit2Px / 4).attr("height", unit2Px / 4)
                             .attr("visibility", "hidden").style("fill", "#ff0000")
                             .on("click", () => {projector = setInterval(ReverseAnim, 1000 / fps);});
        projector = setInterval(LoadAnim, 1000 / fps);
      }

//Create a random hexadecimal color
      function RandomColor() {
        var RGB = [];
        RGB[0] = Math.floor(Math.random() * 256).toString(16);
        RGB[1] = Math.floor(Math.random() * 256).toString(16);
        RGB[2] = Math.floor(Math.random() * 256).toString(16);
        for (j = 0; j < 3; j++) {if (RGB[j].length == 1) {RGB[j] = '0' + RGB[j];}}
        return('#' + RGB[0] + RGB[1] + RGB[2]);
      }

//Control times, and update bots
      function LoadAnim() {
        if (time > timeMax) {
          timeRewind.attr("visibility", "visible");
          timeSlide.attr("visibility", "visible");
          clearInterval(projector);
        } else {
          tourists.forEach((tourist) => {
            tourist.LoadUpdate();
          });

          if (sendSignal == 1) {
            for (var i = 0; i < tourists.length; i++) {
              tourists[i].knows = true;
              tourists[i].on++;
            }
            sendSignal++;
          }

          for (i = 0; i < tourists.length; i++) {
            LoadLines(i);
          }
          time++;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
          timeBox.attr("width", (time / timeMax) * 4 * unit2Px);
        }
      }

//Create lines, and update graph dot positions, as well recreating image of path.
      function LoadLines(i) {
        var dista = unit2Px * 4 - Math.sqrt(Math.pow(fieldExit[0] - tourists[i].x, 2) + Math.pow(fieldExit[1] - tourists[i].y, 2))
        graphDots[i].attr("cx", (time / timeMax) * 4 * unit2Px).attr("cy", dista);
        if (time > 0) {
          tourLines[i].push({x:tourists[i].x, y:tourists[i].y});
          tourLine[i].remove();
          tourLine[i] = fieldSVG.append("path").attr("d", lineFx(tourLines[i]))
                        .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none");
          graphLines[i].push({x:graphDots[i].attr("cx"), y:graphDots[i].attr("cy")});
          graphLine[i].remove();
          graphLine[i] = graphSVG.append("path").attr("d", lineFx(graphLines[i]))
                         .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none");
        } else {
          tourLines[i].push({x:center[0], y:center[1]});
          tourLine.push(fieldSVG.append("path").attr("d", lineFx(tourLines[i]))
                        .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none"));
          graphLines[i].push({x:0, y:3 * unit2Px});
          graphLine.push(graphSVG.append("path").attr("d", lineFx(graphLines[i]))
                         .style("stroke", tourColors[i]).style("stroke-width", 3).style("stroke-opacity", 0.5).style("fill", "none"));
        }
      }

      function PlayAnim() {
        if (time > timeMax) {
          clearInterval(projector);
          timePause.attr("visibility", "hidden");
          timeRewind.attr("visibility", "visible");
        } else {
          timePlay.attr("visibility", "hidden");
          timeRewind.attr("visibility", "hidden");
          timePause.attr("visibility", "visible");
          for (i = 0; i < touristNum; i++) {
            var who = tourists[i];
            who.x = tourLines[i][time].x;
            who.y = tourLines[i][time].y;
            who.visual.attr("cx", who.x).attr("cy", who.y);
            graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
          }
          time++;
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
        }
      }

      function PauseAnim() {
        clearInterval(projector);
        timePause.attr("visibility", "hidden");
        timePlay.attr("visibility", "visible");
        timeRewind.attr("visibility", "visible");
      }

      function ReverseAnim() {
        if (time <= 0) {
          clearInterval(projector);
          timePause.attr("visibility", "hidden");
          timePlay.attr("visibility", "visible");
        } else {
          timePlay.attr("visibility", "hidden");
          timeRewind.attr("visibility", "hidden");
          timePause.attr("visibility", "visible");
          time--;
          for (i = 0; i < touristNum; i++) {
            var who = tourists[i];
            who.x = tourLines[i][time].x;
            who.y = tourLines[i][time].y;
            who.visual.attr("cx", who.x).attr("cy", who.y);
            graphDots[i].attr("cx", graphLines[i][time].x).attr("cy", graphLines[i][time].y);
          }
          timeSlide.attr("x", (time / timeMax) * (31 / 8) * unit2Px);
        }
      }

      //////////----------Initial Function Call----------//////////
      Start();

    </script>
  </body>
</html>
